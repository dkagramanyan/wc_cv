{"/docs/alloy/":{"data":{"":"Наши сплавы были получены жидкофазным спеканием примерно при 1380С (см. статью ). То есть при спекании карбид вольфрама WС был твёрдым - а расплав на основе кобальта - соотвественно, жидким\nНаш сплав находится в районе “optimum” (см. статью )\nПотом материал закаливается, кобальт затвердевает, и мы видим на РЭМ снимках две фазы: светдые ограненные кристаллы WС и темную кобальтовую матрицу между ними.\nУ нас в руках - “победиты” с самой простой для интерпретации структурой, где только две эти фазы (бывает там ещё и графит, другие карбиды и т.д.)"},"title":"Образцы сплава"},"/docs/api/":{"data":{"align_figuresorig_img_padded-tol-labeled_cntsfalse-labelsfalse#align_figures(orig_img_padded, tol, labeled_cnts=False, labels=False)":"Выравнивание фигур на изображении.\nfrom combra import image aligned = image.align_figures( orig_img_padded, tol=5, labeled_cnts=False )","angles#angles":"Модуль для вычисления углов и анализа их распределений.","angles_approx_modesfolder-step-start1-stop1-start2-stop2-width-height-font_size25#angles_approx_modes(folder, step, start1, stop1, start2, stop2, width, height, font_size=25)":"Визуализация мод распределения углов.\nfrom combra import angles angles.angles_approx_modes( folder='results', step=5, start1=0, stop1=180, start2=180, stop2=360, width=10, height=10, font_size=25 )","angles_approx_saveimages_path-save_path-types_dict-step-max_images_num_per_classnone-workersnone#angles_approx_save(images_path, save_path, types_dict, step, max_images_num_per_class=None, workers=None)":"Вычисление и сохранение распределения углов для всех изображений датасета.\nfrom combra import angles, data images_path = data.example_class_path() types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна', 'Ultra_Co8': 'средне-мелкие зерна' } angles.angles_approx_save( images_path=images_path, save_path='angles_results', types_dict=types_dict, step=5, # Шаг в градусах max_images_num_per_class=360, workers=20 ) Параметры:\nimages_path (str): Путь к папке с классами изображений save_path (str): Базовое имя для сохранения JSON файла types_dict (dict): Словарь соответствия имен классов и их описаний step (int): Шаг угла в градусах для гистограммы max_images_num_per_class (int, optional): Максимум изображений на класс workers (int, optional): Количество процессов Возвращает:\nСохраняет JSON файл с именем {save_path}_step_{step}_degrees.json Пример использования сохраненных данных:\nimport json with open('angles_results_step_5_degrees.json', 'r', encoding='utf-8') as f: data = json.load(f) for item in data: print(f\"Класс: {item['name']}\") print(f\"Легенда: {item['legend']}\") x, y = item['density_curve_scatter'] print(f\"Точек в распределении: {len(x)}\")","angles_legendimages_amount-name-itype-step-mus-sigmas-amps-norm#angles_legend(images_amount, name, itype, step, mus, sigmas, amps, norm)":"Создание текстовой легенды для распределения углов.\nfrom combra import angles legend = angles.angles_legend( images_amount=100, name='Ultra_Co11', itype='средние зерна', step=5, mus=[90, 270], sigmas=[30, 30], amps=[1.0, 1.0], norm=1000 )","angles_plot_basedata-plot_file_name-step-n-m-savefalse-indicesnone-font_size20-scatter_size20#angles_plot_base(data, plot_file_name, step, N, M, save=False, indices=None, font_size=20, scatter_size=20)":"Визуализация распределения углов.\nfrom combra import angles import json with open('angles_results_step_5_degrees.json', 'r') as f: data = json.load(f) angles.angles_plot_base( data, plot_file_name='angles_plot', step=5, N=10, # Количество строк в сетке M=10, # Количество столбцов в сетке indices=[0, 1, 2], # Индексы классов для отображения save=True )","api-reference#API Reference":"API ReferenceПолный справочник API для библиотеки combra - компьютерное зрение для композитных сплавов.","approx#approx":"Модуль для аппроксимации данных.","areas#areas":"Модуль для анализа площадей полигонов.","beams_heatmapdata-step-saved_names-indicesnone-bin_max30-n7-m7-font_size20-savefalse-scatter_size60#beams_heatmap(data, step, saved_names, indices=None, bin_max=30, N=7, M=7, font_size=20, save=False, scatter_size=60)":"Визуализация тепловой карты MVEE.\nfrom combra import mvee mvee.beams_heatmap( data, step=4, saved_names=['heatmap'], N=7, M=7, save=True )","bimodal_gauss_approxx-y#bimodal_gauss_approx(x, y)":"Полная бимодальная аппроксимация с возвратом кривой.\nfrom combra import approx (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # Визуализация import matplotlib.pyplot as plt plt.plot(x, y, 'o', label='Данные') plt.plot(x_gauss, y_gauss, '-', label='Аппроксимация') plt.legend() plt.show() Возвращает:\n(x_gauss, y_gauss): Координаты аппроксимирующей кривой mus: [mu1, mu2] sigmas: [sigma1, sigma2] amps: [amp1, amp2]","contours#contours":"Модуль для работы с контурами.","create_crack_graphimg_shape-cnts-nodes_metadata-#create_crack_graph(img_shape, cnts, nodes_metadata, \u0026hellip;)":"Создание ориентированного графа трещин.\nfrom combra import graph import networkx as nx G, img_contours_mono = graph.create_crack_graph( img_contours.shape, cnts, nodes_meta ) print(f\"Узлов: {G.number_of_nodes()}\") print(f\"Ребер: {G.number_of_edges()}\") Возвращает:\nG: NetworkX граф img_contours_mono: Монохромное изображение контуров","data#data":"Модуль для работы с датасетами изображений.","diametr_approx_saveimages_path-save_path-types_dict-step-pixel-start2-end-3-max_images_num_per_classnone#diametr_approx_save(images_path, save_path, types_dict, step, pixel, start=2, end=-3, max_images_num_per_class=None)":"Вычисление и сохранение диаметров (MVEE) для датасета.\nfrom combra import mvee, data images_path = data.example_class_path() types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна' } mvee.diametr_approx_save( images_path=images_path, save_path='mvee_results', types_dict=types_dict, step=4, pixel=50/1000, # Размер пикселя в мм max_images_num_per_class=None )","do_otsuimg#do_otsu(img)":"Бинаризация изображения методом Otsu.\nfrom combra import image binary = image.do_otsu(img)","draw_contoursimage-cnts-color_corner0-139-139-color_line255-140-0-r2-e_width5-l_width2-cornersfalse#draw_contours(image, cnts, color_corner=(0, 139, 139), color_line=(255, 140, 0), r=2, e_width=5, l_width=2, corners=False)":"Визуализация контуров на изображении.\nfrom combra import contours from PIL import Image import numpy as np img_rgb = Image.fromarray(np.zeros((100, 100, 3), dtype=np.uint8)) img_with_contours = contours.draw_contours( img_rgb, cnts, color_corner=(0, 139, 139), color_line=(255, 140, 0), corners=True ) Параметры:\nimage: PIL Image или ndarray cnts: Список контуров color_corner: Цвет углов (RGB) color_line: Цвет линий (RGB) r: Радиус точек углов e_width: Ширина линий контуров l_width: Ширина линий corners: Показывать углы","draw_edgesimage-cnts-color0-139-139-r4-e_width5-l_width4#draw_edges(image, cnts, color=(0, 139, 139), r=4, e_width=5, l_width=4)":"Визуализация ребер контуров.\nfrom combra import contours img_with_edges = contours.draw_edges(image, cnts, color=(0, 139, 139))","draw_treeimg-centresfalse-leafsfalse-nodesfalse-bonesfalse#draw_tree(img, centres=False, leafs=False, nodes=False, bones=False)":"Визуализация дерева на изображении.\nfrom combra import graph graph.draw_tree( img, centres=True, leafs=True, nodes=True )","ellipsea-b-angle-xc0-yc0-num50#ellipse(a, b, angle, xc=0, yc=0, num=50)":"Генерация координат эллипса.\nfrom combra import stats coords = stats.ellipse(a=10, b=5, angle=45, xc=0, yc=0, num=50)","enclosing_ellipse_showimage-pos0-tolerance02-n15#enclosing_ellipse_show(image, pos=0, tolerance=0.2, N=15)":"Визуализация объемлющего эллипса.\nfrom combra import mvee mvee.enclosing_ellipse_show(image, pos=0, tolerance=0.2, N=15)","example_class_path#example_class_path()":"Возвращает путь к папке с примерами классов.\nfrom combra import data path = data.example_class_path() # Возвращает: str","example_crack_fixed_images#example_crack_fixed_images()":"Возвращает список примеров изображений трещин.\nfrom combra import data images = data.example_crack_fixed_images() # Возвращает: List[Tuple[str, np.ndarray]]","example_images#example_images()":"Возвращает список примеров изображений из встроенного датасета.\nfrom combra import data images = data.example_images() # Возвращает: List[Tuple[str, np.ndarray]]","fill_polygongrid-corners-fill_value1#fill_polygon(grid, corners, fill_value=1)":"Заполнение полигона на сетке.\nfrom combra import image filled = image.fill_polygon(grid, corners, fill_value=1)","find_intersection_2dp1-p2-p3-p4#find_intersection_2d(p1, p2, p3, p4)":"Нахождение точки пересечения двух отрезков в 2D.\nfrom combra import image intersection = image.find_intersection_2d(p1, p2, p3, p4)","find_shortest_energy_pathsg-energies_paths-#find_shortest_energy_paths(g, energies_paths, \u0026hellip;)":"Поиск кратчайших путей по энергиям.\nfrom combra import graph paths = graph.find_shortest_energy_paths( g, energies_paths, ... )","gaussian_bimodalx-mu1-mu2-sigma1-sigma2-amp11-amp21#gaussian_bimodal(x, mu1, mu2, sigma1, sigma2, amp1=1, amp2=1)":"Бимодальная гауссова функция.\nfrom combra import stats y = stats.gaussian_bimodal( x, mu1=90, mu2=270, sigma1=30, sigma2=30, amp1=1, amp2=1 )","gaussian_fit_bimodalx-y-mu1100-mu2240-sigma130-sigma230-amp11-amp21#gaussian_fit_bimodal(x, y, mu1=100, mu2=240, sigma1=30, sigma2=30, amp1=1, amp2=1)":"Аппроксимация данных бимодальной гауссовой функцией.\nfrom combra import approx mus, sigmas, amps = approx.gaussian_fit_bimodal( x, y, mu1=90, mu2=270, sigma1=30, sigma2=30, amp1=1, amp2=1 ) Возвращает:\nmus: [mu1, mu2] sigmas: [sigma1, sigma2] amps: [amp1, amp2]","gaussian_fit_termodalx-y-mu110-mu2100-mu3240-sigma110-sigma230-sigma330-amp11-amp21-amp31#gaussian_fit_termodal(x, y, mu1=10, mu2=100, mu3=240, sigma1=10, sigma2=30, sigma3=30, amp1=1, amp2=1, amp3=1)":"Аппроксимация данных термодальной гауссовой функцией.\nfrom combra import approx mus, sigmas, amps = approx.gaussian_fit_termodal( x, y, mu1=10, mu2=100, mu3=240, sigma1=10, sigma2=30, sigma3=30, amp1=1, amp2=1, amp3=1 )","gaussian_fitx-y-mu1-sigma1-amp1#gaussian_fit(x, y, mu=1, sigma=1, amp=1)":"Аппроксимация данных одной гауссовой функцией.\nfrom combra import approx import numpy as np x = np.linspace(0, 360, 100) y = some_data # Ваши данные mu, sigma, amp = approx.gaussian_fit(x, y, mu=100, sigma=30, amp=1) print(f\"μ={mu:.2f}, σ={sigma:.2f}, A={amp:.2f}\") Возвращает:\nmu: Среднее значение sigma: Стандартное отклонение amp: Амплитуда","gaussian_termodalx-mu1-mu2-mu3-sigma1-sigma2-sigma3-amp11-amp21-amp31#gaussian_termodal(x, mu1, mu2, mu3, sigma1, sigma2, sigma3, amp1=1, amp2=1, amp3=1)":"Термодальная гауссова функция.\nfrom combra import stats y = stats.gaussian_termodal( x, mu1=10, mu2=100, mu3=240, sigma1=10, sigma2=30, sigma3=30, amp1=1, amp2=1, amp3=1 )","gaussianx-mu-sigma-amp1#gaussian(x, mu, sigma, amp=1)":"Гауссова функция.\nfrom combra import stats import numpy as np x = np.linspace(0, 360, 100) y = stats.gaussian(x, mu=100, sigma=30, amp=1)","get_anglesimage-border_eps5-tol3#get_angles(image, border_eps=5, tol=3)":"Вычисление углов на контурах изображения.\nfrom combra import angles from combra import image processed = image.image_preprocess(img) angles_array, contours = angles.get_angles(processed, border_eps=5, tol=3) Параметры:\nimage (ndarray): Предобработанное изображение (width, height, 1) border_eps (int): Расстояние от края изображения до внутреннего края tol (int): Точность упрощения контуров Возвращает:\nangles (ndarray): Массив углов в градусах contours (list): Список обработанных контуров Пример:\nfrom combra import angles, image, data from skimage import io # Загрузка и предобработка img = io.imread('image.png') processed = image.image_preprocess(img) # Вычисление углов angles_array, cnts = angles.get_angles(processed, border_eps=5, tol=3) print(f\"Найдено углов: {len(angles_array)}\") print(f\"Средний угол: {angles_array.mean():.2f}°\")","get_bresenham_eps_pixelsimg_contours_np-start_node_x-start_node_y-end_node_x-end_node_y-border_pixel255#get_bresenham_eps_pixels(img_contours_np, start_node_x, start_node_y, end_node_x, end_node_y, border_pixel=255)":"Получение пикселей вдоль линии Брезенхема с эпсилон-окрестностью.\nfrom combra import image pixels = image.get_bresenham_eps_pixels( img_contours_np, x1, y1, x2, y2, border_pixel=255 )","get_contoursimage-tol3#get_contours(image, tol=3)":"Извлечение контуров с упрощением алгоритмом Дугласа-Пекера.\nfrom combra import contours cnts = contours.get_contours(image, tol=3) Параметры:\nimage (ndarray): Входное изображение tol (int): Максимальное расстояние от исходных точек до упрощенной полигональной цепи Возвращает:\nlist: Список упрощенных контуров Пример:\nfrom combra import image, contours from skimage import io # Предобработка img = io.imread('image.png') processed = image.image_preprocess(img) # Извлечение контуров cnts = contours.get_contours(processed, tol=3) print(f\"Найдено контуров: {len(cnts)}\")","get_edge_type_labelednode1-node2-nodes_metadata-line_eps10#get_edge_type_labeled(node1, node2, nodes_metadata, line_eps=10)":"Определение типа ребра для размеченных данных.\nfrom combra import graph edge_type = graph.get_edge_type_labeled( node1, node2, nodes_metadata, line_eps=10 )","get_edge_typenode1-node2-cnts-nodes_metadata-wc_eps30-border_pixel0#get_edge_type(node1, node2, cnts, nodes_metadata, wc_eps=30, border_pixel=0)":"Определение типа ребра между узлами.\nfrom combra import graph edge_type = graph.get_edge_type( node1, node2, cnts, nodes_metadata, wc_eps=30 ) # Возвращает: 0 (Co), 1 (WC-Co), 2 (WC), 3 (WC-WC)","get_energiesg-cnts-nodes_metadata-entry_nodes-exit_nodes-#get_energies(g, cnts, nodes_metadata, entry_nodes, exit_nodes, \u0026hellip;)":"Вычисление энергий путей в графе.\nfrom combra import graph energies = graph.get_energies( g, cnts, nodes_metadata, entry_nodes, exit_nodes, workers=23 )","get_mvee_paramsimage-tol02#get_mvee_params(image, tol=0.2)":"Вычисление параметров MVEE для изображения.\nfrom combra import mvee params = mvee.get_mvee_params(image, tol=0.2)","get_perp_vstart_node_x-start_node_y-end_node_x-end_node_y-line_eps10#get_perp_v(start_node_x, start_node_y, end_node_x, end_node_y, line_eps=10)":"Вычисление перпендикулярного вектора к линии.\nfrom combra import image perp_vector = image.get_perp_v(x1, y1, x2, y2, line_eps=10)","get_row_contoursimage#get_row_contours(image)":"Извлечение сырых контуров из изображения.\nfrom combra import contours cnts = contours.get_row_contours(image) # Возвращает: list of ndarray, каждый элемент - массив координат точек контура Параметры:\nimage (ndarray): Входное изображение (width, height, 3) Возвращает:\nlist: Список контуров, каждый контур - массив формы (M_points, 2)","graph#graph":"Модуль для построения и анализа графов трещин.","graph_plotg-img_contours-n50-m50-namegraphjpg-border30-savefalse#graph_plot(g, img_contours, N=50, M=50, name=\u0026lsquo;graph.jpg\u0026rsquo;, border=30, save=False)":"Визуализация графа на изображении.\nfrom combra import graph graph.graph_plot( G, img_contours, N=10, M=10, name='crack_graph.png', save=True )","image#image":"Модуль для предобработки изображений.","image_preprocessimage#image_preprocess(image)":"Основная функция предобработки изображения: медианный фильтр, бинаризация Otsu и градиент.\nfrom combra import image from skimage import io img = io.imread('path/to/image.png') processed = image.image_preprocess(img) Параметры:\nimage (ndarray): Входное изображение (height, width, channels) Возвращает:\nndarray: Предобработанное изображение (height, width, 1)","is_point_in_polygonx-y-corners#is_point_in_polygon(x, y, corners)":"Проверка, находится ли точка внутри полигона.\nfrom combra import image inside = image.is_point_in_polygon(x, y, corners)","lin_regr_approxx-y#lin_regr_approx(x, y)":"Линейная регрессия.\nfrom combra import approx slope, intercept = approx.lin_regr_approx(x, y)","mark_corners_and_classesimage-max_num100000-sens01-max_dist1#mark_corners_and_classes(image, max_num=100000, sens=0.1, max_dist=1)":"Обнаружение углов и классификация по градиентам.\nfrom combra import contours corners, classes, num = contours.mark_corners_and_classes( image, max_num=100000, sens=0.1, max_dist=1 )","mvee#mvee":"Модуль для работы с минимальным объемлющим эллипсоидом (MVEE).","plot_anglesdata-saved_image_name-step-n-m-indicesnone-savefalse#plot_angles(data, saved_image_name, step, N, M, indices=None, save=False)":"Визуализация углов MVEE.\nfrom combra import mvee mvee.plot_angles(data, 'angles_plot', step=4, N=7, M=7, save=True)","plot_beam_basedata-save_name-step-n-m-indicesnone-savefalse-scatter_size60-font_size20#plot_beam_base(data, save_name, step, N, M, indices=None, save=False, scatter_size=60, font_size=20)":"Визуализация базовых данных MVEE.\nfrom combra import mvee import json with open('mvee_results_step_4_beams.json', 'r') as f: data = json.load(f) mvee.plot_beam_base( data, save_name='mvee_plot', step=4, N=7, M=7, save=True )","plot_optimized_energies#plot_optimized_energies(\u0026hellip;)":"Визуализация матриц энергий.\nfrom combra import graph graph.plot_optimized_energies( energies, ... )","plot_optimized_pathsg-energies_paths-img_contours_o-param_110-param_210#plot_optimized_paths(g, energies_paths, img_contours_o, param_1=10, param_2=10)":"Визуализация оптимизированных путей.\nfrom combra import graph graph.plot_optimized_paths( G, energies_paths, img_contours_o, param_1=10, param_2=10 )","plot_pathsg-df-img_aligned-border30#plot_paths(g, df, img_aligned, border=30)":"Визуализация путей на изображении.\nfrom combra import graph graph.plot_paths(G, paths_df, img_aligned, border=30)","plot_polygons_areadata-saved_image_name-step-n-m-indicesnone-savefalse-start1-endnone-pixel501000-font_size20-s60-log_min_val-8-min_area_num10#plot_polygons_area(data, saved_image_name, step, N, M, indices=None, save=False, start=1, end=None, pixel=50/1000, font_size=20, s=60, log_min_val=-8, min_area_num=10)":"Визуализация распределения площадей полигонов.\nfrom combra import areas import json with open('areas_data.json', 'r') as f: data = json.load(f) areas.plot_polygons_area( data, saved_image_name='areas_plot', step=5, N=10, M=10, pixel=50/1000, # Размер пикселя в мм save=True )","plot_polygons_effective_radiusdata-saved_image_name-step-n-m-indicesnone-savefalse-start1-endnone-#plot_polygons_effective_radius(data, saved_image_name, step, N, M, indices=None, save=False, start=1, end=None, \u0026hellip;)":"Визуализация эффективных радиусов полигонов.\nfrom combra import areas areas.plot_polygons_effective_radius( data, saved_image_name='radius_plot', step=5, N=10, M=10, save=True )","preprocess_graph_imageimage-r2-border30-border_node_eps10-tol5-disk5-labeled_cntsfalse-labelsfalse-#preprocess_graph_image(image, r=2, border=30, border_node_eps=10, tol=5, disk=5, labeled_cnts=False, labels=False, \u0026hellip;)":"Предобработка изображения для построения графа трещин.\nfrom combra import graph, image from skimage import io img = io.imread('crack_image.png') processed = image.image_preprocess(img) entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image( processed, r=2, border=30, border_node_eps=10, tol=5 ) ) Возвращает:\nentry_nodes: Входные узлы графа exit_nodes: Выходные узлы графа img_contours: Изображение с контурами img_marked: Размеченное изображение cnts: Список контуров nodes_meta: Метаданные узлов","preprocess_imageimage-padfalse-border30-disk3#preprocess_image(image, pad=False, border=30, disk=3)":"Предобработка изображения с опциональным добавлением границы.\nfrom combra.data.dataset import SEMDataset processed = SEMDataset.preprocess_image( image, pad=True, border=30, disk=3 ) Параметры:\nimage (ndarray): Входное изображение pad (bool): Добавить границу border (int): Размер границы в пикселях disk (int): Размер диска для медианного фильтра","semdataset#SEMDataset":"Класс для загрузки и предобработки датасета изображений с автоматическим кэшированием.\nfrom combra.data.dataset import SEMDataset dataset = SEMDataset( images_folder_path='path/to/images', max_images_num_per_class=100, workers=None # По умолчанию: cpu_count()-1 ) # Получить изображение и путь image, path = dataset.__getitem__(class_idx=0, idx=0) # Количество классов num_classes = len(dataset) Параметры:\nimages_folder_path (str): Путь к корневой папке с подпапками-классами (не должен оканчиваться на /) max_images_num_per_class (int): Максимальное количество изображений на класс workers (int, optional): Количество процессов для параллельной обработки Методы:\n__getitem__(class_idx, idx): Возвращает кортеж (image, path) для указанного класса и индекса __len__(): Возвращает количество классов preprocess_image(image, pad=False, border=30, disk=3): Статический метод для предобработки одного изображения Пример:\nfrom combra.data.dataset import SEMDataset # Создание датасета (автоматически кэширует в /tmp) dataset = SEMDataset('data/wc_co', max_images_num_per_class=50) # Итерация по всем классам и изображениям for class_idx in range(len(dataset)): for img_idx in range(dataset.images_paths.shape[1]): image, path = dataset.__getitem__(class_idx, img_idx) # Обработка изображения print(f\"Class {class_idx}, Image {img_idx}: {path}\")","skeletons_coordsimage#skeletons_coords(image)":"Извлечение координат скелетов из бинаризованного изображения.\nfrom combra import contours bones = contours.skeletons_coords(binary_image)","stats#stats":"Модуль для статистической обработки.","stats_preprocessarray-step#stats_preprocess(array, step)":"Предобработка массива для статистического анализа.\nfrom combra import stats angles = np.array([...]) # Массив углов x, y = stats.stats_preprocess(angles, step=5) # x - центры бинов, y - частоты Параметры:\narray (ndarray): Входной массив данных step (float): Шаг для гистограммы Возвращает:\nx: Центры бинов y: Частоты","модули#Модули":"Библиотека combra организована в следующие модули:\ndata - Работа с датасетами и примерами данных image - Предобработка изображений contours - Извлечение и обработка контуров angles - Вычисление углов и их распределений graph - Построение и анализ графов трещин mvee - Минимальный объемлющий эллипсоид (MVEE) areas - Анализ площадей полигонов approx - Аппроксимация данных stats - Статистическая обработка и распределения","полный-пример-использования#Полный пример использования":"from combra import data, image, angles, approx, stats from skimage import io import json # 1. Загрузка примера данных images_path = data.example_class_path() # 2. Обработка одного изображения img = io.imread('path/to/image.png') processed = image.image_preprocess(img) # 3. Вычисление углов angles_array, contours = angles.get_angles(processed, border_eps=5, tol=3) # 4. Статистическая обработка x, y = stats.stats_preprocess(angles_array, step=5) # 5. Аппроксимация (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # 6. Визуализация import matplotlib.pyplot as plt plt.plot(x, y, 'o', label='Данные') plt.plot(x_gauss, y_gauss, '-', label='Аппроксимация') plt.xlabel('Угол (градусы)') plt.ylabel('Частота') plt.legend() plt.show() # 7. Обработка всего датасета types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна' } angles.angles_approx_save( images_path=images_path, save_path='results', types_dict=types_dict, step=5, max_images_num_per_class=100 )"},"title":"API Reference"},"/docs/approx/":{"data":{"":"","bimodal_gauss_approxx-y#bimodal_gauss_approx(x, y)":"Аппроксимация распределения бимодальным гауссом\nПараметры:\nx: list (n,) y: list (n,) Возвращает: (x_gauss, y_gauss), mus, sigmas, amps","gaussian_fit_bimodalx-y-mu1100-mu2240-sigma130-sigma230-amp11-amp21#gaussian_fit_bimodal(x, y, mu1=100, mu2=240, sigma1=30, sigma2=30, amp1=1, amp2=1)":"Аппроксимация заданных точек бимодальной нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu1: float mu2: float sigma1: float sigma2: float amp1: float amp2: float Возвращает: mus, sigmas, amps","gaussian_fit_termodalx-y-mu110-mu2100-mu3240-sigma110-sigma230-sigma330-amp11-amp21-amp31#gaussian_fit_termodal(x, y, mu1=10, mu2=100, mu3=240, sigma1=10, sigma2=30, sigma3=30, amp1=1, amp2=1, amp3=1)":"Аппроксимация заданных точек термодальной нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu1: float mu2: float mu3: float sigma1: float sigma2: float sigma3: float amp1: float amp2: float amp3: float Возвращает: mus, sigmas, amps","gaussian_fitx-y-mu1-sigma1-amp1#gaussian_fit(x, y, mu=1, sigma=1, amp=1)":"Аппроксимация заданных точек нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu: float sigma: float amp: float Возвращает: mus, sigmas, amps","lin_regr_approxx-y#lin_regr_approx(x, y)":"Аппроксимация распределения линейной функцией и создание графика по параметрам распределения\nПараметры:\nx: list (n,) y: list (n,) Возвращает: (x_pred, y_pred), k, b, angle, score"},"title":"Approximation"},"/docs/blender/":{"data":{"":"Для генерации снимков на Windows необходимо установить Blender и загрузить файл GrainGenerator_pobedit.blend. В разделе Scripting в строке 92 указать путь к папке, в которой необходимо сохранить снимки (всё, что до “‘blender’+” и так далее), в том же формате и запустить скрипт. Будут созданы три образца, и с каждого будут сделаны три снимка и сохранены по указанному пути.\nЕсли не сработает, нужно открыть терминал Blender (в левом верхнем углу Window-Toggle System Console), там будут указаны ошибки\nДля запуска в Linux предположительно нужно использовать команду:\nblender yourblendfilenameorpath --python drawcar.py При запуске на Харизме вставить части кода, помеченные “для генерации на харизме”, и удалить строки, помеченные “для генерации локально”"},"title":"Blender"},"/docs/draw/":{"data":{"":"","draw_cornersimage-corners-color255#draw_corners(image, corners, color=255)":"Наносит на изображение точки в местах, где есть углы списка corners\nПараметры:\nimage: ndarray (width, height, channels) corners: list (n_corners,2) color: int Возвращает: ndarray (width, height, channels)","draw_edgesimage-cnts-color50-50-50#draw_edges(image, cnts, color=(50, 50, 50))":"Рисует на изображении линии по точкам контура cnts, линии в стиле x^1-\u003ex^2,x^2-\u003ex^3 и тд\nПараметры:\nimage: ndarray (width, height, channels) cnts: ndarray (n_cnts,n,2) color: tuple (3,) Возвращает: ndarray (width, height, channels)","draw_treeimage-centresfalse-leafsfalse-nodesfalse-bonesfalse#draw_tree(image, centres=False, leafs=False, nodes=False, bones=False)":"На вход подается бинаризованное изображение. Рисует на инвертированном изображении скелет: точки их центров, листьев, узлов и пикселей скелета\nПараметры:\nimg: ndarray (width, height) centres: Bool leafs: Bool nodes: Bool bones: Bool Возвращает: ndarray (width, height, channels)"},"title":"Draw"},"/docs/fig/":{"data":{"":"","linepoint1-point2#line(point1, point2)":"Возвращает растровые координаты прямой между двумя точками при помощи алгоритма Брезенхема Параметры:\npoint1: tuple (int, int) point2: tuple (int, int) Возвращает: ndarray (n_points,(x,y))","rectpoint1-point2#rect(point1, point2)":"Возвращает растровые координаты прямоугольника ширины 2r, построеного между двумя точками. Не ясно зачем умножать в размерность на 2.\nПараметры:\npoint1: tuple (int, int) point2: tuple (int, int) r: int Возвращает: tuple (n_points, rect_diag*2,2)"},"title":"Fig"},"/docs/generate/":{"data":{"":"","angles_approx_savefolder-images-names-types-step-savetrue#angles_approx_save(folder, images, names, types, step, save=True)":"Вычисление и сохранение распределения углов для всех фотографий одного образца\nПараметры:\nfolder: str path to dir images: ndarray uint8 [[image1_class1,image2_class1,..],[image1_class2,image2_class2,..]..] names: list str [class_name1,class_name2,..] types: list str [class_type1,class_type2,..] step: scalar int [0,N] save: bool","angles_legendimages_amount-name-itype-step-mus-sigmas-amps-norm#angles_legend(images_amount, name, itype, step, mus, sigmas, amps, norm)":"Cоздание легенды распределения углов\nПараметры:\nimages_amount: int name: str itype: str step: int mus: float sigmas: float amps: float norm: int Возвращает: str","beams_legendname-itype-norm-k-angle-b-score-dist_step-dist_mean#beams_legend(name, itype, norm, k, angle, b, score, dist_step, dist_mean)":"Создание легенды для распределения длин полуосей\nПараметры:\nname: str itype: str norm: int k: float angle: float b: float score: float dist_step: int dist_mean: float Возвращает: str","diametr_approx_savefolder-images-names-types-step-pixel-start2-end-3-savetrue-debugfalse#diametr_approx_save(folder, images, names, types, step, pixel, start=2, end=-3, save=True, debug=False)":"Вычисление и сохранение распределения длин а- и б- полуосей и угла поворота эллипса для разных образцов\nПараметры:\nfolder: str images: ndarray uint8 [[image1_class1,image2_class1,..],[image1_class2,image2_class2,..]..] names: list str [class_name1,class_name2,..] types: list str [class_type1,class_type2,..] step: scalar int [0,N] pixel: float start: int end: int save: bool debug: bool Возвращает: None"},"title":"Generate"},"/docs/images_source/":{"data":{"":"Полученые шлифы проходили предварительное микроскопическое исследование с помощью оптической микроскопии до и после травления в реактиве Мураками для выявления включений свободного углерода и фазы, а также растровой электронной микроскопии (РЭМ) и рентгеновского микроанализа на приборе Tescan Vega TS5130 MM, оборудованном энерго- дисперсионным спектрометром LINK производства фирмы Oxford Instruments. Размер изображения 100 на 100 мкм. Размер цифрового изображения 3072 на 1680 пикселей, каждый пиксель имеет 256 оттенков серого."},"title":"Описание снимков"},"/docs/install/":{"data":{"":"","зависимости#Зависимости":"Основные зависимости устанавливаются автоматически при установке пакета. Основные библиотеки:\nnumpy - работа с массивами scikit-image - обработка изображений networkx - работа с графами lmfit - аппроксимация функций opencv-python - компьютерное зрение mpire - параллельная обработка","проверка-установки#Проверка установки":"import combra print(f\"combra version: {combra.__version__}\") # Проверка основных модулей from combra import data, image, angles, graph print(\"Все модули успешно импортированы!\") Тестовые изображения находятся в хранилище s3 по адресам\nhttps://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co11.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co15.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co25.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co6_2.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co8.jpg","установка-из-исходников#Установка из исходников":"Для работы с библиотекой combra склонируйте репозиторий и установите пакет в режиме разработки:\ngit clone https://github.com/dkagramanyan/wc_cv cd wc_cv/combra pip install -e . Требуемая версия Python - 3.8 или выше."},"title":"Установка"},"/docs/introduction/":{"data":{"":"Добыча полезных ископаемых и строительство сложных сооружений на протяжении многих столетий являются важными задачами. Их объединяет повышенное требование к применяемым инструментам, в частности сверлильным установкам. Зачастую для добычи природного газа, нефти или строительства линий метрополитена требуется сделать глубокие шахты в твердой неоднородной породе, где на бурильную головку оказывается сильное давление и температура. Для такой работы характеристики наконечников бурильной головки должны максимально точно соответствовать требованиям окружающей среды. Например, твердосплавные напайки должны быть достаточно твердыми, чтобы эффективно разрушать породу, но и одновременно пластичными, чтобы не расколоться о случайный камень высокой прочности.\nС развитием материаловедения получилось выделить группу твердых сплавов карбида вольфрама с кобальтом (WC-Co), которые обладают высокими и гибкими прочностными характеристиками. Например, сплав будет более пластичным и меньше подтвержен выкрашиванию зерен, если добавить больше связующего вещества (кобальта). За многие годы успели достаточно подробно изучить все характеристики этого сплава, однако мы не можем утверждать, что у нее изучены все свойства.\nСуществует гипотеза о том, что между физическими характеристиками сплава присутствуют нелинейные зависимости. Есть множество работ по изучению сплавов WC-Co с различным процентным содержанием компонентов, однако тема поиска скрытых взаимосвязей остается нераскрытой. Цель этой работы - разработать программный комплекс для выделения на снимках микроструктур WC-Co важных признаков и поиска зависимостей между характеристиками сплава.\nСамым многообещающими способами поиска зависимостей являются алгоритмы машинного обучения и компьютерного зрения. Современные модели нейронных сетей способны выявлять сложные зависимости между самыми разными видами данных. В арсенале компьютерного зрения присутствует множество алгоритмов, которые эффективно выделяет геометрию на изображениях.\nДля достижения цели необходимо исследовать и протестировать большой набор алгоритмов выделения признаков на снимках микроструктуры сплава. Затем полученные признаки нужно сопоставить характеристиками сплава, такими как: твердость, ударная вязкость, пластичность, коэффициенты ударной адиабаты и тд. Важно также провести моделирование сплава в различных CAD системах для того, чтобы сравнить вычисленные параметры с экспериментальными.\nОжидаемый результат работы - программный комплекс для обработки SEM снимков микроструктур сплава WC-Co и анализ скрытых зависимостей между физическими характеристиками.\nУ данной работы есть явная практическая польза. В случае, если скрытые зависимости действительно есть, то математическая модель сплава WC-Co будет дополнена новыми данными. Как следствие - инженеры при изготовлении и применении твердосплавных напаек будут знать больше о поведении этого сплава при выпекании и работе при различных внешних условиях. Это поможет сократить издержки и повысит ресурс сверлильных установок.\nВажно понимать, что ценность работы не уменьшится, если искомых скрытых зависимостей не окажется. В дальнейшем можно будет использовать разработанный программный комплекс для анализа изображений, других сплавов или других предметных областей, таких как биология и астрономия."},"title":"Введение"},"/docs/logs/":{"data":{"":"","printprogressbariteration-total-prefix-suffix-decimals1-length100-fill-printendr-etanone#printProgressBar(iteration, total, prefix=\u0026rsquo;\u0026rsquo;, suffix=\u0026rsquo;\u0026rsquo;, decimals=1, length=100, fill=\u0026rsquo;█\u0026rsquo;, printEnd=\u0026quot;\\r\u0026quot;, eta=None)":"Вызывает цикл для вывода прогресс бара\nПараметры:\ncurrent iteration: Int total iterations: Int prefix string: Str suffix string: Str positive number of decimals in percent complete: Int character length of bar: Int bar fill character: Str end character (e.g. \"\\r\", \"\\r\\n\"): Str"},"title":"Logs"},"/docs/mark/":{"data":{"":"","get_anglesimage-thr5#get_angles(image, thr=5)":"Возвращает углы с направлением обхода контура против часовой стрелки, углы \u003e180 градусов учитываются. На вход принимает только обработанное изображение\nПараметры:\nimage: ndarray (width, height,1), only preprocessed image thr: int, distance from original image edge to inner image edge (rect in rect) Возвращает: angles ndarray (n), angles coords list (n_angles, 2)","get_contourscls-image-tol3#get_contours(cls, image, tol=3)":"Уменьшение количества точек контура при помощи алгоритма Дугласа-Пекера\nПараметры:\nimage: ndarray (width, height,3) tol: int Maximum distance from original points of polygon to approximated polygonal chain Возвращает: list (N_contours, (M_points,2))","get_mvee_paramsimage-tol02-debugfalse#get_mvee_params(image, tol=0.2, debug=False)":"Возвращает полуоси и угол поворота фигуры minimal volume enclosing ellipsoid, которая ограничивает исходные точки контура эллипсом. Для расчетов центр координатной оси сдвигается на центроид полигона (исследуемого региона), а затем сдвигается на среднее значение координат полигона\nПараметры:\nimage: ndarray (width, height,1), only preprocessed image tol: foat, koef of ellipse compactness Возвращает: ndarray a_beams, b_beams, angles, centroids","get_row_contoursimage#get_row_contours(image)":"Возвращает кооридинаты пикселей контуров каждого региона\nПараметры:\nimage: ndarray (width, height,3) Возвращает: list (N_contours, (M_points,2))","gskeletons_coordsimage#gskeletons_coords(image)":"На вход подается бинаризованное изображение создает массив индивидуальных скелетов пикселю скелета дается класс, на координатах которого он находится. Координаты класса определяются ndi.label\nПараметры:\nimage: ndarray (width, height,1) Возвращает: bones","mark_corners_and_classesimage-max_num100000-sens01-max_dist1#mark_corners_and_classes(image, max_num=100000, sens=0.1, max_dist=1)":"(Deprecated) Возвращает всевозможные координаты углов и исходное изображение с нанесенными классами кластеров градиента\nПараметры:\nimage: ndarray (width, height, channels) max_num: int sens: float max_dist: int Возвращает: corners, classes, num","mean_pixelimage-point1-point2-r#mean_pixel(image, point1, point2, r)":"(Deprecated) Возвращает среднее значение пикселей прямоугольника ширины 2r, построеного между двумя точками\nПараметры:\nimage: ndarray (width, height, channels) point1: tuple (int, int) point2: tuple (int, int) r: int Возвращает: mean, dist","вписывание-регионов-co-в-эллипс#Вписывание регионов Co в эллипс":"Задача вписывания фигуры в эллипс называется minimal volume enclosing ellipsoid. Алгоритм решения задачи был разработан Л.Н.Хачуяном . Мы взяли релизацию этого алгоритма из библиотеки Radio_Beam . Параметры эллипсоида подбираются так, чтобы заданные точки находились внутри фигуры, а ее геометрические характеристики были наименьшими.","класс-grainmark#Класс grainMark":"","определение-углов-у-регионов-co#Определение углов у регионов Co":"Для определения углов последовательно используется 3 инстурмента:\nпоиск границ Кенни. Он находит на изображении все возможные границы и затем выделяет их\nметод поиска конутров Suzuki. Он нужен для разметки (нумерования) пикселей найденных в п.1 контуров. Направление обхода контура - против часовой стрелки. Проверим направление. Точка - начало отрисовки контура\nполученные масивы пикселей контуров аппроксимируются методом Дугласа-Пекера. Он из массива точек оставляет только те точки, которые описывают характер полигона, например: точки в углах, перегибах и тд В итоге для каждого контура мы имеем массив точек, которые с заданной точностью описывают периметр контура.\nДля определения границы воспользуемся определителем тройкой векторов. Если определитель det меньше 0, то угол phi меньше 180 градусов, иначе больше 180.\ngrainMark.get_row_contours(image)"},"title":"Mark"},"/docs/morphology/":{"data":{"":"","kmeans_imageimage-n_clusters#kmeans_image(image, n_clusters)":"Кластеризует при помощи kmeans и возвращает изображение с нанесенными цветами кластеров\nПараметры:\nimage: ndarray (width, height, channels) n_clusters: int Возвращает: (image, colors), colors - list of median colors of the clusters"},"title":"Morphology"},"/docs/nn/":{"data":{"":"Для использования снимков нужно создать модель автоэнкодер, которая из снимков будет вытягивать вектор признаков. Затем этот вектор вместе с вычисленными характеристиками будет отправлться на вход другой нейронной сети, которая будет искать зависимости между входными значениями и физическими характеристиками сплавов","архитектура#Архитектура:":"Веса AE (tf) Веса VQ-VAE-2 (pt)"},"title":"Машинное обучение"},"/docs/preprocess/":{"data":{"":"Описанные инструменты разработаны для обработки SEM снимков.\nДля явного выделения границ фаз WC/Co используется последовательное применение следующиих алгоритом\nвыбирается сторона снимка. По умолчанию использвуется снимок в отраженных электронах\nизображение сглаживается медианным фильтром для подавления шумов и выравнивания цветового распределения пикселей\nслаженное изображение бинаризуется при помощи метода Отсу\nот бинаризованного изображения берется градиент. Он явно показывает переходы вас WC/Co\nбинаризованное изобржение инвертируется и к нему добавляется карта градиентов, полученная в п.4\nПолная обработка изображения выглядит следующим образом:\npreproc_image=1-Otsu(median_filter(image))+grad(Otsu(median_filter(image))) Значения пикселей по классам:\n0 - зерно WC\n127 - регион Co\n254 - граница региона Co, смежного с зернами WC. Толщина границы - 1 пиксель","combineimage-h-k05#combine(image, h, k=0.5)":"Накладывает левую и правые части изображения. Если k=1, то на выходе будет левая часть изображения, если k=0, то будет правая часть\nПараметры:\nimage: ndarray (height,width,channels) h: int scalar k: float scalar Возвращает: ndarray (height,width/2,channels)","do_otsuimage#do_otsu(image)":"Бинаризация Отсу\nПараметры:\nimg: ndarray (height,width,channels) Возвращает: ndarray (height,width), Boolean","get_example_images#get_example_images()":"Скачивает из контейнера s3 по 1 снимку каждого образца\nВозвращает: ndarray [[img1],[img2]..]","image_preprocess_kmeansimage-h135-k1-n_clusters3-pos1#image_preprocess_kmeans(image, h=135, k=1, n_clusters=3, pos=1)":"Выделение границ при помощи кластеризации и выравнивание шума медианным фильтром. Подходит только для смазанных фотограий, где границы у объектов достатчно широкие. Pos отвечает за выбор кластера, который будет отображен на возвращенном изображении\nПараметры:\nimage: array (height,width,channels) h: int scalar k: float scalar n_clusters: int scalar pos: int scalar, cluster index Возвращает: ndarray (height,width)","image_preprocessimage#image_preprocess(image)":"Комбинация медианного фильтра, биноризации и градиента. У зерен значение пикселя - 0, у регионов связ. в-ва - 127,а у их границы - 254. Обраотанное изображение получается следующим образом: 1-Otsu(median_filter(image))+grad(Otsu(median_filter(image)))\nПараметры:\nimg: ndarray (height,width,channels) Возвращает: ndarray (height,width,1)","imdivideimage-h-side#imdivide(image, h, side)":"Разделяет входное изображение по середине и возвращает левую или правую часть\nПараметры:\nimage: ndarray (height,width,channels) h: int scalar side: float scalar Возвращает: ndarray (height,width/2,channels)","read_preprocess_dataimages_dir-max_images_num_per_class100-preprocessfalse-savefalse-crop_bottomfalse-h135-resizetrue-resize_shapenone-save_nameall_imagesnpy#read_preprocess_data(images_dir, max_images_num_per_class=100, preprocess=False, save=False, crop_bottom=False, h=135, resize=True, resize_shape=None, save_name=\u0026lsquo;all_images.npy\u0026rsquo;)":"Считывание всего датасета, обработка и сохрание в .npy файл\nПараметры:\nimages_dir: str max_images_num_per_class: int preprocess: Bool save: Bool crop_bottom: Bool h: int resize: Bool resize_shape: tuple (width, height, channels) save_name: str Возвращает: ndarray (n_classes, n_images_per_class, width, height, channels)","tiff2jpgfolder_path-start_name0-stop_name-4-new_folder_pathresized#tiff2jpg(folder_path, start_name=0, stop_name=-4, new_folder_path=\u0026lsquo;resized\u0026rsquo;)":"Переводит из tiff 2^16 в jpg 2^8 бит\nПараметры:\nfolder_path: str start_name: int stop_name: int new_folder_path: str Возвращает: None","класс-grainpreprocess#Класс grainPreprocess":"","обработка-всего-датасета-снимков#Обработка всего датасета снимков":"all_images=grainPreprocess.read_preprocess_data(images_folder_path, images_num_per_class=150, preprocess=True, save=True)","обработка-одного-снимка#Обработка одного снимка":"img=io.imread(img_path) img=grainPreprocess.image_preprocess(img,h,k)","расположение-снимков#Расположение снимков":"Расположение исходных снимков и предобработанных снимков должно выглядеть следующим образом\nproject │ └───images_folder │ └───class1_images │ image1 │ image2 │ ... └───class2_images │ image1 │ image2 │ ... └───class3_images │ image1 │ image2 │ ..."},"title":"Предобработка изображений"},"/docs/show/":{"data":{"":"","enclosing_ellipse_showimage-pos0-tolerance02-n15#enclosing_ellipse_show(image, pos=0, tolerance=0.2, N=15)":"Выводит точки многоугольника с позиции pos и описанного вокруг него эллипса\nПараметры:\nimage: ndarray (height,width,channels) pos: int tolerance: foat, koef of ellipse compactness N: int Возвращает: None","img_showimage-n20-cmappltcmnipy_spectral#img_show(image, N=20, cmap=plt.cm.nipy_spectral)":"Выводит изображение image\nПараметры:\nimage: ndarray (height,width,channels) N: int cmap: plt cmap Возвращает: None"},"title":"Show"},"/docs/stats/":{"data":{"":"","ellipsea-b-angle-xc0-yc0-num50#ellipse(a, b, angle, xc=0, yc=0, num=50)":"Возвращает координаты эллипса, построенного по заданным параметрам. По умолчанию центр (0,0). Угол в радианах, уменьшение угла обозначает поворот эллипса по часовой стрелке\nПараметры:\na: float b: float angle: float, rad xc: float, center coord x yc: float, center coord y num: int, number of ellipse points Возвращает: tuple (num, 2)","gaussian_bimodalx-mu1-mu2-sigma1-sigma2-amp11-amp21#gaussian_bimodal(x, mu1, mu2, sigma1, sigma2, amp1=1, amp2=1)":"Возвращает бимодальную нормальную фунцию по заданным параметрам\nПараметры:\nx: list (n,) mu1: float mu2: float sigma1: float sigma2: float amp1: float amp2: float Возвращает: list (n,)","gaussian_termodalx-mu1-mu2-mu3-sigma1-sigma2-sigma3-amp11-amp21-amp31#gaussian_termodal(x, mu1, mu2, mu3, sigma1, sigma2, sigma3, amp1=1, amp2=1, amp3=1)":"Возвращает термодальную нормальную фунцию по заданным параметрам\nПараметры:\nx: list (n,) mu1: float mu2: float mu3: float sigma1: float sigma2: float sigma3: float amp1: float amp2: float amp3: float Возвращает: list (n,)","gaussianx-mu-sigma-amp1#gaussian(x, mu, sigma, amp=1)":"Наносит на изображение точки в местах, где есть углы списка corners\nПараметры:\nx: list (n,) mu: float sigma: float amp: float Возвращает: list (n,)","kernel_pointsimage-point-step1#kernel_points(image, point, step=1)":"Возвращает координаты пикселей квадратной матрицы шириной 2*step, центр которой это point\nПараметры:\nimage: ndarray (width, height) point: tuple (2,) step: int Возвращает: tuple (n_points,2)","stats_preprocessarray-step#stats_preprocess(array, step)":"Приведение углов к кратости, например 0,step,2*step и тд\nПараметры:\narray: list, ndarray (n,) step: int Возвращает: array_copy, array_copy_set, dens_curve"},"title":"Stats"},"/docs/usage_angles/":{"data":{"angles_approx_modes#\u003ccode\u003eangles_approx_modes()\u003c/code\u003e":"Визуализация мод распределения углов.\nfrom combra import angles angles.angles_approx_modes( folder='results', # Папка с JSON файлами step=5, start1=0, stop1=180, # Диапазон первой моды start2=180, stop2=360, # Диапазон второй моды width=10, height=10, font_size=25 )","angles_approx_save#\u003ccode\u003eangles_approx_save()\u003c/code\u003e":"Вычисляет и сохраняет распределения углов для всех изображений в датасете с автоматической аппроксимацией.\nfrom combra import angles, data import json # Путь к датасету images_path = data.example_class_path() # Словарь типов зерен types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна', 'Ultra_Co8': 'средне-мелкие зерна', 'Ultra_Co6_2': 'крупные зерна', 'Ultra_Co15': 'средне-мелкие зерна' } # Вычисление и сохранение angles.angles_approx_save( images_path=images_path, save_path='angles_results', types_dict=types_dict, step=5, # Шаг угла в градусах max_images_num_per_class=360, workers=20 # Количество процессов ) Параметры:\nimages_path (str): Путь к папке с классами изображений save_path (str): Базовое имя для сохранения JSON файла types_dict (dict): Словарь соответствия имен классов и их описаний step (int): Шаг угла в градусах для гистограммы max_images_num_per_class (int, optional): Максимум изображений на класс workers (int, optional): Количество процессов для параллельной обработки Результат: Создается JSON файл с именем {save_path}_step_{step}_degrees.json содержащий:\nПути к изображениям Имена классов Текстовые легенды с параметрами распределений Данные для визуализации (гистограммы) Параметры гауссовой аппроксимации Структура JSON файла:\n[ { \"path\": \"/path/to/class\", \"name\": \"Ultra_Co11\", \"type\": \"средние зерна\", \"legend\": \"--------------\\nUltra_Co11 средние зерна\\n количество углов 1000\\n...\", \"density_curve_scatter\": [[0, 5, 10, ...], [10, 15, 20, ...]], \"gauss_approx_plot\": [[0, 1, 2, ...], [5.2, 5.5, 5.8, ...]], \"gauss_approx_data\": { \"mus\": [90.5, 270.3], \"sigmas\": [30.2, 28.7], \"amps\": [1.0, 0.95] } }, ... ]","angles_legend#\u003ccode\u003eangles_legend()\u003c/code\u003e":"Создание текстовой легенды для распределения углов.\nfrom combra import angles legend = angles.angles_legend( images_amount=100, # Количество изображений name='Ultra_Co11', # Имя класса itype='средние зерна', # Тип зерен step=5, # Шаг угла mus=[90.5, 270.3], # Средние значения мод sigmas=[30.2, 28.7], # Стандартные отклонения amps=[1.0, 0.95], # Амплитуды norm=1000 # Общее количество углов ) print(legend)","angles_plot_base#\u003ccode\u003eangles_plot_base()\u003c/code\u003e":"Визуализация распределений углов для нескольких классов.\nfrom combra import angles import json # Загрузка данных with open('angles_results_step_5_degrees.json', 'r', encoding='utf-8') as f: data = json.load(f) # Визуализация angles.angles_plot_base( data, plot_file_name='angles_plot', step=5, N=10, # Количество строк в сетке M=10, # Количество столбцов в сетке indices=[0, 1, 2], # Индексы классов для отображения save=True, font_size=20, scatter_size=20 ) Параметры:\ndata: Данные из JSON файла plot_file_name: Базовое имя для сохранения графиков step: Шаг угла в градусах N, M: Размеры сетки графиков indices: Список индексов классов для отображения (если None, отображаются все) save: Сохранить графики font_size: Размер шрифта scatter_size: Размер точек на графике","border_eps#\u003ccode\u003eborder_eps\u003c/code\u003e":"Маленькие значения (3-5): Больше углов, но могут быть артефакты на краях Большие значения (10-15): Меньше углов, но более надежные результаты","get_angles#\u003ccode\u003eget_angles()\u003c/code\u003e":"Основная функция для вычисления углов на предобработанном изображении.\nfrom combra import angles, image from skimage import io # Предобработка изображения img = io.imread('image.png') processed = image.image_preprocess(img) # Вычисление углов angles_array, contours = angles.get_angles( processed, border_eps=5, # Расстояние от края изображения tol=3 # Точность упрощения контуров ) print(f\"Найдено углов: {len(angles_array)}\") print(f\"Средний угол: {angles_array.mean():.2f}°\") print(f\"Медианный угол: {np.median(angles_array):.2f}°\") Параметры:\nimage (ndarray): Предобработанное изображение (width, height, 1) border_eps (int): Расстояние от края изображения до внутреннего края (игнорируются контуры слишком близко к краю) tol (int): Точность упрощения контуров алгоритмом Дугласа-Пекера Возвращает:\nangles (ndarray): Массив углов в градусах contours (list): Список обработанных контуров Пример использования:\nimport numpy as np import matplotlib.pyplot as plt from combra import angles, image, stats, approx from skimage import io # Загрузка и предобработка img = io.imread('grain_image.png') processed = image.image_preprocess(img) # Вычисление углов angles_array, cnts = angles.get_angles(processed, border_eps=5, tol=3) # Статистика print(f\"Всего углов: {len(angles_array)}\") print(f\"Минимальный угол: {angles_array.min():.2f}°\") print(f\"Максимальный угол: {angles_array.max():.2f}°\") print(f\"Средний угол: {angles_array.mean():.2f}°\") print(f\"Стандартное отклонение: {angles_array.std():.2f}°\") # Гистограмма plt.hist(angles_array, bins=36, edgecolor='black') plt.xlabel('Угол (градусы)') plt.ylabel('Частота') plt.title('Распределение углов') plt.show()","step-шаг-для-гистограммы#\u003ccode\u003estep\u003c/code\u003e (шаг для гистограммы)":"5 градусов: Стандартное значение, хороший баланс 1-2 градуса: Высокая детализация, больше шума 10 градусов: Меньше деталей, более гладкие распределения","tol-точность-упрощения#\u003ccode\u003etol\u003c/code\u003e (точность упрощения)":"Маленькие значения (1-3): Более точные контуры, больше точек, медленнее Большие значения (5-10): Меньше точек, быстрее, но может теряться детализация","визуализация#Визуализация":"","вычисление-углов-для-одного-изображения#Вычисление углов для одного изображения":"","загрузка-и-анализ-результатов#Загрузка и анализ результатов":"import json # Загрузка результатов with open('angles_results_step_5_degrees.json', 'r', encoding='utf-8') as f: data = json.load(f) # Анализ каждого класса for item in data: print(f\"\\nКласс: {item['name']}\") print(f\"Тип: {item['type']}\") print(f\"Легенда:\\n{item['legend']}\") # Данные для визуализации x, y = item['density_curve_scatter'] print(f\"Точек в распределении: {len(x)}\") # Параметры аппроксимации mus = item['gauss_approx_data']['mus'] sigmas = item['gauss_approx_data']['sigmas'] amps = item['gauss_approx_data']['amps'] print(f\"Мода 1: μ={mus[0]:.2f}°, σ={sigmas[0]:.2f}°\") print(f\"Мода 2: μ={mus[1]:.2f}°, σ={sigmas[1]:.2f}°\")","интеграция-с-модулем-stats#Интеграция с модулем stats":"from combra import angles, stats, approx import matplotlib.pyplot as plt import numpy as np # Вычисление углов angles_array, _ = angles.get_angles(processed, border_eps=5, tol=3) # Предобработка для статистики x, y = stats.stats_preprocess(angles_array, step=5) # Бимодальная гауссова аппроксимация (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # Визуализация plt.figure(figsize=(12, 6)) plt.plot(x, y, 'o', label='Данные', markersize=4, alpha=0.6) plt.plot(x_gauss, y_gauss, '-', label='Бимодальная аппроксимация', linewidth=2) plt.xlabel('Угол (градусы)', fontsize=12) plt.ylabel('Частота', fontsize=12) plt.title('Распределение углов с аппроксимацией', fontsize=14) plt.legend(fontsize=11) plt.grid(True, alpha=0.3) plt.show() print(f\"Мода 1: μ={mus[0]:.2f}°, σ={sigmas[0]:.2f}°, A={amps[0]:.2f}\") print(f\"Мода 2: μ={mus[1]:.2f}°, σ={sigmas[1]:.2f}°, A={amps[1]:.2f}\")","обзор#Обзор":"Углы вычисляются на упрощенных контурах зерен:\nКонтуры упрощаются алгоритмом Дугласа-Пекера Для каждой точки контура вычисляется угол между соседними сегментами Углы измеряются в градусах (0-360°) Учитывается направление обхода контура (против часовой стрелки)","обработка-всего-датасета#Обработка всего датасета":"","полный-пример#Полный пример":"from combra import angles, image, data, stats, approx from skimage import io import json import matplotlib.pyplot as plt import numpy as np # 1. Обработка одного изображения img = io.imread('grain_image.png') processed = image.image_preprocess(img) angles_array, cnts = angles.get_angles(processed, border_eps=5, tol=3) # 2. Статистический анализ x, y = stats.stats_preprocess(angles_array, step=5) (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # 3. Визуализация plt.figure(figsize=(12, 6)) plt.plot(x, y, 'o', label='Данные', markersize=4) plt.plot(x_gauss, y_gauss, '-', label='Аппроксимация', linewidth=2) plt.xlabel('Угол (градусы)') plt.ylabel('Частота') plt.legend() plt.show() # 4. Обработка всего датасета images_path = data.example_class_path() types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна' } angles.angles_approx_save( images_path=images_path, save_path='results', types_dict=types_dict, step=5, max_images_num_per_class=100 ) # 5. Загрузка и визуализация результатов with open('results_step_5_degrees.json', 'r', encoding='utf-8') as f: results = json.load(f) angles.angles_plot_base( results, plot_file_name='angles_plot', step=5, N=10, M=10, save=True )","примечания#Примечания":"Углы вычисляются с учетом направления обхода контура (против часовой стрелки) Углы \u003e180° учитываются (полный диапазон 0-360°) Контуры слишком близко к краю изображения игнорируются Для больших датасетов рекомендуется использовать параллельную обработку (workers параметр)","рекомендации-по-параметрам#Рекомендации по параметрам":"","создание-легенды#Создание легенды":"","статистический-анализ#Статистический анализ":"","углы-и-их-распределения#Углы и их распределения":"Углы и их распределенияМодуль angles предоставляет функциональность для вычисления углов на контурах зерен и анализа их распределений."},"title":"Углы и их распределения"},"/docs/usage_dataset/":{"data":{"__getitem__class_idx-idx#\u003ccode\u003e__getitem__(class_idx, idx)\u003c/code\u003e":"Получение изображения и пути.\nПараметры:\nclass_idx (int): Индекс класса idx (int): Индекс изображения в классе Возвращает:\ntuple: (image, path) где image - numpy array, path - строка с путем","__init__images_folder_path-max_images_num_per_class100-workersnone#\u003ccode\u003e__init__(images_folder_path, max_images_num_per_class=100, workers=None)\u003c/code\u003e":"Инициализация датасета.","__len__#\u003ccode\u003e__len__()\u003c/code\u003e":"Возвращает количество классов в датасете.","preprocess_imageimage-padfalse-border30-disk3-classmethod#\u003ccode\u003epreprocess_image(image, pad=False, border=30, disk=3)\u003c/code\u003e (classmethod)":"Статический метод для предобработки одного изображения.\nПараметры:\nimage (ndarray): Входное изображение pad (bool): Добавить границу border (int): Размер границы disk (int): Размер диска для медианного фильтра Возвращает:\nndarray: Предобработанное изображение","базовый-пример#Базовый пример":"from combra.data.dataset import SEMDataset # Создание датасета dataset = SEMDataset('data/wc_co', max_images_num_per_class=50) # Получение первого изображения первого класса image, path = dataset.__getitem__(0, 0) print(f\"Загружено: {path}\") print(f\"Размер: {image.shape}\")","датасет-semdataset#Датасет: SEMDataset":"Датасет: SEMDatasetКласс SEMDataset подготавливает кэш предобработанных изображений в /tmp/\u003cимя_датасета\u003e и предоставляет удобный доступ к изображениям и их путям.","доступ-к-данным#Доступ к данным":"","использование-метода-предобработки-отдельно#Использование метода предобработки отдельно":"from combra.data.dataset import SEMDataset from skimage import io # Загрузка изображения image = io.imread('path/to/image.jpg') # Предобработка processed = SEMDataset.preprocess_image( image, pad=False, # Добавить границу border=30, # Размер границы в пикселях disk=3 # Размер диска для медианного фильтра )","использование-с-другими-модулями#Использование с другими модулями":"from combra.data.dataset import SEMDataset from combra import angles, stats, approx import matplotlib.pyplot as plt # Создание датасета dataset = SEMDataset('data/wc_co', max_images_num_per_class=50) # Сбор углов из всех изображений all_angles = [] for class_idx in range(len(dataset)): for img_idx in range(dataset.images_paths.shape[1]): image, _ = dataset.__getitem__(class_idx, img_idx) angles_array, _ = angles.get_angles(image) all_angles.extend(angles_array) # Статистический анализ x, y = stats.stats_preprocess(all_angles, step=5) # Аппроксимация (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # Визуализация plt.plot(x, y, 'o', label='Данные') plt.plot(x_gauss, y_gauss, '-', label='Аппроксимация') plt.legend() plt.show()","итерация-по-датасету#Итерация по датасету":"# Итерация по всем классам и изображениям for class_idx in range(len(dataset)): num_images = dataset.images_paths.shape[1] for img_idx in range(num_images): image, path = dataset.__getitem__(class_idx, img_idx) # Обработка изображения print(f\"Класс {class_idx}, Изображение {img_idx}: {path}\")","количество-классов#Количество классов":"# Количество классов в датасете num_classes = len(dataset) print(f\"Классов в датасете: {num_classes}\")","кэширование#Кэширование":"Датасет автоматически кэширует предобработанные изображения в /tmp/\u003cимя_датасета\u003e.","методы-класса#Методы класса":"","обработка-всех-изображений#Обработка всех изображений":"from combra.data.dataset import SEMDataset from combra import angles dataset = SEMDataset('data/wc_co', max_images_num_per_class=100) all_angles = [] for class_idx in range(len(dataset)): for img_idx in range(dataset.images_paths.shape[1]): image, path = dataset.__getitem__(class_idx, img_idx) # Вычисление углов angles_array, _ = angles.get_angles(image, border_eps=5, tol=3) all_angles.extend(angles_array) print(f\"Обработано: {path}\") print(f\"Всего углов: {len(all_angles)}\")","основные-возможности#Основные возможности":"Автоматическое кэширование предобработанных изображений Параллельная обработка с использованием всех доступных CPU ядер Проверка целостности кэша и автоматическое обновление при необходимости Поддержка структуры папок с классами изображений","очистка-кэша#Очистка кэша":"import shutil import os cache_dir = '/tmp/wc_co' # Замените на имя вашего датасета if os.path.exists(cache_dir): shutil.rmtree(cache_dir) print(\"Кэш удален\")","получение-изображения#Получение изображения":"# Получить изображение и путь по индексам класса и изображения image, path = dataset.__getitem__(class_idx=0, idx=0) print(f\"Путь к изображению: {path}\") print(f\"Форма изображения: {image.shape}\")","предобработка-изображений#Предобработка изображений":"Класс автоматически применяет предобработку к каждому изображению:\nКонвертация в grayscale (если необходимо) Медианная фильтрация Бинаризация методом Otsu Вычисление градиента","примеры-использования#Примеры использования":"","примечания#Примечания":"Путь к датасету не должен оканчиваться на / Кэш создается однократно и переиспользуется при последующих запусках Предобработанные изображения сохраняются в формате PNG Все изображения должны иметь одинаковый размер (проверка не выполняется автоматически)","проверка-кэша#Проверка кэша":"При создании датасета выполняется проверка:\nСуществования кэша Соответствия структуры папок Количества изображений Если кэш неполный или устарел, он автоматически пересоздается.","создание-датасета#Создание датасета":"from combra.data.dataset import SEMDataset # Создание датасета # Путь не должен оканчиваться на '/' dataset = SEMDataset( images_folder_path='data/wc_co', max_images_num_per_class=100, workers=None # По умолчанию: cpu_count()-1 ) Параметры:\nimages_folder_path (str): Корневая папка с подпапками-классами. Важно: путь не должен оканчиваться на / max_images_num_per_class (int): Лимит изображений на класс. Если None, используются все доступные изображения workers (int, optional): Количество процессов для параллельной обработки. По умолчанию cpu_count()-1","структура-папок#Структура папок":"Датасет ожидает следующую структуру:\ndata/wc_co/ ├── Ultra_Co11/ │ ├── image1.jpg │ ├── image2.jpg │ └── ... ├── Ultra_Co25/ │ ├── image1.jpg │ └── ... └── Ultra_Co8/ └── ..."},"title":"Датасет: SEMDataset"},"/docs/usage_graph/":{"data":{"create_crack_graph#\u003ccode\u003ecreate_crack_graph()\u003c/code\u003e":"Создает ориентированный граф трещин на основе контуров и метаданных узлов.\nG, img_contours_mono = graph.create_crack_graph( img_shape, cnts, nodes_metadata, # Дополнительные параметры... ) Параметры:\nimg_shape: Форма изображения (tuple) cnts: Список контуров nodes_metadata: Словарь с метаданными узлов Возвращает:\nG: NetworkX ориентированный граф img_contours_mono: Монохромное изображение контуров Структура графа:\nУзлы содержат атрибуты: координаты, тип узла Ребра содержат атрибуты: тип ребра, длина, энергия (если вычислена)","draw_tree#\u003ccode\u003edraw_tree()\u003c/code\u003e":"Визуализирует дерево на изображении.\ngraph.draw_tree( img, centres=False, # Показывать центры leafs=False, # Показывать листья nodes=False, # Показывать узлы bones=False # Показывать кости )","find_shortest_energy_paths#\u003ccode\u003efind_shortest_energy_paths()\u003c/code\u003e":"Находит кратчайшие пути в графе на основе вычисленных энергий.\npaths = graph.find_shortest_energy_paths( g, energies_paths, ... )","get_edge_type#\u003ccode\u003eget_edge_type()\u003c/code\u003e":"Определяет тип ребра между двумя узлами на основе анализа пикселей вдоль линии.\nedge_type = graph.get_edge_type( node1, node2, cnts, nodes_metadata, wc_eps=30, border_pixel=0 ) Типы ребер:\n0: Co (кобальт) 1: WC-Co (граница вольфрама-кобальта) 2: WC (вольфрам-карбид) 3: WC-WC (граница вольфрама-вольфрама)","get_edge_type_labeled#\u003ccode\u003eget_edge_type_labeled()\u003c/code\u003e":"Определение типа ребра для размеченных данных.\nedge_type = graph.get_edge_type_labeled( node1, node2, nodes_metadata, line_eps=10 )","get_energies#\u003ccode\u003eget_energies()\u003c/code\u003e":"Вычисляет энергии путей в графе для различных конфигураций.\nenergies = graph.get_energies( g, cnts, nodes_metadata, entry_nodes, exit_nodes, workers=23 ) Параметры:\ng: NetworkX граф cnts: Список контуров nodes_metadata: Метаданные узлов entry_nodes: Входные узлы exit_nodes: Выходные узлы workers: Количество процессов Возвращает:\nСловарь с энергиями для различных конфигураций","graph_plot#\u003ccode\u003egraph_plot()\u003c/code\u003e":"Визуализирует граф на изображении контуров.\ngraph.graph_plot( g, img_contours, N=50, # Количество строк в сетке M=50, # Количество столбцов в сетке name='graph.jpg', # Имя файла для сохранения border=30, # Размер границы save=False # Сохранить изображение ) Пример:\ngraph.graph_plot( G, img_contours_mono, N=10, M=10, name='crack_graph.png', border=30, save=True )","plot_optimized_energies#\u003ccode\u003eplot_optimized_energies()\u003c/code\u003e":"Визуализирует матрицы энергий для различных конфигураций.\ngraph.plot_optimized_energies( energies, ... )","plot_optimized_paths#\u003ccode\u003eplot_optimized_paths()\u003c/code\u003e":"Визуализирует оптимизированные пути.\ngraph.plot_optimized_paths( g, energies_paths, img_contours_o, param_1=10, param_2=10 )","plot_paths#\u003ccode\u003eplot_paths()\u003c/code\u003e":"Визуализирует пути на выровненном изображении.\ngraph.plot_paths( g, df, # DataFrame с путями img_aligned, # Выровненное изображение border=30 )","preprocess_graph_image#\u003ccode\u003epreprocess_graph_image()\u003c/code\u003e":"Подготавливает изображение для построения графа: выделяет контуры, находит узлы, определяет входные и выходные узлы.\nentry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image( image, r=2, # Радиус для обработки border=30, # Размер границы border_node_eps=10, # Эпсилон для узлов на границе tol=5, # Точность упрощения контуров disk=5, # Размер диска для морфологии labeled_cnts=False, # Использовать размеченные контуры labels=False # Использовать метки ) ) Параметры:\nimage (ndarray): Предобработанное изображение r (int): Радиус для обработки узлов border (int): Размер границы в пикселях border_node_eps (int): Порог для определения узлов на границе tol (int): Точность упрощения контуров (алгоритм Дугласа-Пекера) disk (int): Размер диска для морфологических операций labeled_cnts (bool): Использовать размеченные контуры labels (bool): Использовать метки классов Возвращает:\nentry_nodes: Список индексов входных узлов exit_nodes: Список индексов выходных узлов img_contours: Изображение с контурами img_marked: Размеченное изображение cnts: Список контуров nodes_meta: Словарь с метаданными узлов","визуализация#Визуализация":"","вычисление-энергий#Вычисление энергий":"","граф-трещин#Граф трещин":"Граф трещинМодуль graph предоставляет функциональность для построения и анализа графов трещин на изображениях композитных сплавов.","минимальный-пример#Минимальный пример":"from combra import graph, image from skimage import io # 1. Загрузка и предобработка изображения img = io.imread('path/to/crack_image.png') processed = image.image_preprocess(img) # 2. Предобработка для графа entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image( processed, r=2, border=30, border_node_eps=10, tol=5 ) ) # 3. Создание графа G, img_contours_mono = graph.create_crack_graph( img_contours.shape, cnts, nodes_meta ) print(f\"Узлов в графе: {G.number_of_nodes()}\") print(f\"Ребер в графе: {G.number_of_edges()}\") # 4. Визуализация graph.graph_plot( G, img_contours_mono, N=10, M=10, name='crack_graph.png', save=True )","настройка-для-разных-типов-изображений#Настройка для разных типов изображений":"Высокое разрешение: увеличьте border и border_node_eps Много шума: увеличьте disk для морфологии Сложные контуры: уменьшите tol для большей точности","обзор#Обзор":"Граф трещин представляет собой ориентированный граф, где:\nУзлы соответствуют точкам пересечения или разветвления трещин Ребра соответствуют сегментам трещин между узлами Типы ребер классифицируются по материалу: Co, WC-Co, WC, WC-WC","пайплайн-работы#Пайплайн работы":"Предобработка изображения (image.image_preprocess) Предобработка для графа (graph.preprocess_graph_image) - выделение контуров, подготовка метаданных узлов Построение графа (graph.create_crack_graph) - создание ориентированного графа Вычисление энергий (опционально) (graph.get_energies) - расчет энергий путей Визуализация (graph.graph_plot) - отображение графа на изображении","параметры-и-настройки#Параметры и настройки":"","полный-пример#Полный пример":"from combra import graph, image, contours from skimage import io import networkx as nx # 1. Загрузка и предобработка img = io.imread('crack_image.png') processed = image.image_preprocess(img) # 2. Предобработка для графа entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image( processed, r=2, border=30, border_node_eps=10, tol=5 ) ) # 3. Создание графа G, img_contours_mono = graph.create_crack_graph( img_contours.shape, cnts, nodes_meta ) # 4. Анализ графа print(f\"Узлов: {G.number_of_nodes()}\") print(f\"Ребер: {G.number_of_edges()}\") print(f\"Входных узлов: {len(entry_nodes)}\") print(f\"Выходных узлов: {len(exit_nodes)}\") # 5. Вычисление энергий (опционально) energies = graph.get_energies( G, cnts, nodes_meta, entry_nodes, exit_nodes, workers=4 ) # 6. Визуализация graph.graph_plot( G, img_contours_mono, N=10, M=10, name='crack_graph.png', save=True ) # 7. Анализ типов ребер edge_types = {} for u, v, data in G.edges(data=True): edge_type = data.get('type', 'unknown') edge_types[edge_type] = edge_types.get(edge_type, 0) + 1 print(\"Распределение типов ребер:\") for edge_type, count in edge_types.items(): type_names = {0: 'Co', 1: 'WC-Co', 2: 'WC', 3: 'WC-WC'} print(f\" {type_names.get(edge_type, 'Unknown')}: {count}\")","построение-графа#Построение графа":"","предобработка-для-графа#Предобработка для графа":"","примечания#Примечания":"Граф является ориентированным (directed) Узлы на границе изображения автоматически определяются как входные/выходные Типы ребер определяются на основе анализа пикселей вдоль линии между узлами Для больших изображений рекомендуется использовать параллельную обработку (workers параметр)","работа-с-networkx#Работа с NetworkX":"Поскольку граф является объектом NetworkX, можно использовать все стандартные функции NetworkX:\nimport networkx as nx # Поиск кратчайших путей if nx.has_path(G, source=entry_nodes[0], target=exit_nodes[0]): path = nx.shortest_path(G, source=entry_nodes[0], target=exit_nodes[0]) print(f\"Кратчайший путь: {path}\") # Вычисление центральности centrality = nx.degree_centrality(G) print(f\"Наиболее центральный узел: {max(centrality, key=centrality.get)}\") # Поиск компонент связности components = list(nx.weakly_connected_components(G)) print(f\"Компонент связности: {len(components)}\")","рекомендуемые-параметры#Рекомендуемые параметры":"Для большинства случаев подходят следующие параметры:\n# Предобработка processed = image.image_preprocess(img) # Предобработка для графа entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image( processed, r=2, # Стандартное значение border=30, # Зависит от размера изображения border_node_eps=10, # Стандартное значение tol=5, # Баланс между точностью и производительностью disk=5 # Стандартное значение ) )","типы-ребер#Типы ребер":""},"title":"Граф трещин"},"/docs/usage_quickstart/":{"data":{"mvee-минимальный-объемлющий-эллипсоид#MVEE (Минимальный объемлющий эллипсоид)":"from combra import mvee, data images_path = data.example_class_path() types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна' } # Вычисление MVEE для датасета mvee.diametr_approx_save( images_path=images_path, save_path='mvee_results', types_dict=types_dict, step=4, pixel=50/1000, # Размер пикселя в мм max_images_num_per_class=None ) # Загрузка и визуализация import json with open('mvee_results_step_4_beams.json', 'r') as f: mvee_data = json.load(f) mvee.plot_beam_base( mvee_data, save_name='mvee_plot', step=4, N=7, M=7, save=True )","быстрый-старт#Быстрый старт":"Быстрый стартНиже приведены минимальные примеры использования основных функций пакета combra.","визуализация-графа#Визуализация графа":"from combra import graph graph.graph_plot( G, img_contours, N=10, M=10, name='crack_graph.png', save=True )","визуализация-контуров#Визуализация контуров":"from combra import contours from PIL import Image import numpy as np # Создание RGB изображения img_rgb = Image.fromarray(np.zeros_like(processed, dtype=np.uint8).repeat(3, axis=2)) # Рисование контуров img_with_contours = contours.draw_contours( img_rgb, cnts=cnts, color_corner=(0, 139, 139), color_line=(255, 140, 0), corners=True )","вычисление-углов#Вычисление углов":"from combra import angles angles_array, contours = angles.get_angles(processed, border_eps=5, tol=3) print(f\"Найдено углов: {len(angles_array)}\") print(f\"Средний угол: {angles_array.mean():.2f}°\")","граф-трещин#Граф трещин":"","извлечение-контуров#Извлечение контуров":"from combra import contours cnts = contours.get_contours(processed, tol=3) print(f\"Найдено контуров: {len(cnts)}\")","обработка-всего-датасета-углов#Обработка всего датасета углов":"from combra import angles, data import json # Путь к датасету images_path = data.example_class_path() # Словарь типов зерен types_dict = { 'Ultra_Co11': 'средние зерна', 'Ultra_Co25': 'мелкие зерна', 'Ultra_Co8': 'средне-мелкие зерна', 'Ultra_Co6_2': 'крупные зерна', 'Ultra_Co15': 'средне-мелкие зерна' } # Вычисление и сохранение распределений углов angles.angles_approx_save( images_path=images_path, save_path='angles_results', types_dict=types_dict, step=5, # Шаг в градусах max_images_num_per_class=360, workers=20 ) # Загрузка результатов with open('angles_results_step_5_degrees.json', 'r', encoding='utf-8') as f: results = json.load(f) # Визуализация angles.angles_plot_base( results, plot_file_name='angles_plot', step=5, N=10, M=10, indices=[0, 1, 2], # Индексы классов для отображения save=True )","предобработка-одного-снимка#Предобработка одного снимка":"from combra import image from skimage import io image_raw = io.imread('path/to/image.png') processed = image.image_preprocess(image_raw) Функция image_preprocess выполняет:\nМедианную фильтрацию Бинаризацию методом Otsu Вычисление градиента","работа-с-датасетом#Работа с датасетом":"from combra.data.dataset import SEMDataset # Создание датасета (автоматически кэширует предобработанные изображения в /tmp) dataset = SEMDataset('data/wc_co', max_images_num_per_class=50) # Получение изображения и пути image, path = dataset.__getitem__(0, 0) print(f\"Загружено изображение: {path}\") # Количество классов print(f\"Классов в датасете: {len(dataset)}\")","следующие-шаги#Следующие шаги":"Для более подробной информации см.:\nДатасет: SEMDataset - подробнее о работе с датасетами Граф трещин - детали построения графов Углы - анализ углов и распределений API Reference - полный справочник API","создание-графа#Создание графа":"from combra import graph, image from skimage import io # Предобработка изображения img = io.imread('crack_image.png') processed = image.image_preprocess(img) # Предобработка для графа entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( graph.preprocess_graph_image(processed, tol=5) ) # Создание графа G, img_contours_mono = graph.create_crack_graph( img_contours.shape, cnts, nodes_meta ) print(f\"Узлов в графе: {G.number_of_nodes()}\") print(f\"Ребер в графе: {G.number_of_edges()}\")","статистический-анализ-и-аппроксимация#Статистический анализ и аппроксимация":"from combra import stats, approx import matplotlib.pyplot as plt import numpy as np # Предобработка данных x, y = stats.stats_preprocess(angles_array, step=5) # Бимодальная гауссова аппроксимация (x_gauss, y_gauss), mus, sigmas, amps = approx.bimodal_gauss_approx(x, y) # Визуализация plt.figure(figsize=(10, 6)) plt.plot(x, y, 'o', label='Данные', markersize=4) plt.plot(x_gauss, y_gauss, '-', label='Аппроксимация', linewidth=2) plt.xlabel('Угол (градусы)') plt.ylabel('Частота') plt.title('Распределение углов') plt.legend() plt.grid(True, alpha=0.3) plt.show() print(f\"Мода 1: μ={mus[0]:.2f}°, σ={sigmas[0]:.2f}°\") print(f\"Мода 2: μ={mus[1]:.2f}°, σ={sigmas[1]:.2f}°\")","установка#Установка":"pip install -e ."},"title":"Быстрый старт"}}