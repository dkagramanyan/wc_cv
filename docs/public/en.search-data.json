{"/docs/alloy/":{"data":{"":"Наши сплавы были получены жидкофазным спеканием примерно при 1380С (см. статью ). То есть при спекании карбид вольфрама WС был твёрдым - а расплав на основе кобальта - соотвественно, жидким\nНаш сплав находится в районе “optimum” (см. статью )\nПотом материал закаливается, кобальт затвердевает, и мы видим на РЭМ снимках две фазы: светдые ограненные кристаллы WС и темную кобальтовую матрицу между ними.\nУ нас в руках - “победиты” с самой простой для интерпретации структурой, где только две эти фазы (бывает там ещё и графит, другие карбиды и т.д.)"},"title":"Образцы сплава"},"/docs/api/":{"data":{"":"API Reference для модуля wc_cv.\nДля подробной информации о функциях и классах см. соответствующие разделы документации."},"title":"API Reference"},"/docs/approx/":{"data":{"":"","bimodal_gauss_approxx-y#bimodal_gauss_approx(x, y)":"Аппроксимация распределения бимодальным гауссом\nПараметры:\nx: list (n,) y: list (n,) Возвращает: (x_gauss, y_gauss), mus, sigmas, amps","gaussian_fit_bimodalx-y-mu1100-mu2240-sigma130-sigma230-amp11-amp21#gaussian_fit_bimodal(x, y, mu1=100, mu2=240, sigma1=30, sigma2=30, amp1=1, amp2=1)":"Аппроксимация заданных точек бимодальной нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu1: float mu2: float sigma1: float sigma2: float amp1: float amp2: float Возвращает: mus, sigmas, amps","gaussian_fit_termodalx-y-mu110-mu2100-mu3240-sigma110-sigma230-sigma330-amp11-amp21-amp31#gaussian_fit_termodal(x, y, mu1=10, mu2=100, mu3=240, sigma1=10, sigma2=30, sigma3=30, amp1=1, amp2=1, amp3=1)":"Аппроксимация заданных точек термодальной нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu1: float mu2: float mu3: float sigma1: float sigma2: float sigma3: float amp1: float amp2: float amp3: float Возвращает: mus, sigmas, amps","gaussian_fitx-y-mu1-sigma1-amp1#gaussian_fit(x, y, mu=1, sigma=1, amp=1)":"Аппроксимация заданных точек нормальной функцией\nПараметры:\nx: list (n,) y: list (n,) mu: float sigma: float amp: float Возвращает: mus, sigmas, amps","lin_regr_approxx-y#lin_regr_approx(x, y)":"Аппроксимация распределения линейной функцией и создание графика по параметрам распределения\nПараметры:\nx: list (n,) y: list (n,) Возвращает: (x_pred, y_pred), k, b, angle, score"},"title":"Approximation"},"/docs/blender/":{"data":{"":"Для генерации снимков на Windows необходимо установить Blender и загрузить файл GrainGenerator_pobedit.blend. В разделе Scripting в строке 92 указать путь к папке, в которой необходимо сохранить снимки (всё, что до “‘blender’+” и так далее), в том же формате и запустить скрипт. Будут созданы три образца, и с каждого будут сделаны три снимка и сохранены по указанному пути.\nЕсли не сработает, нужно открыть терминал Blender (в левом верхнем углу Window-Toggle System Console), там будут указаны ошибки\nДля запуска в Linux предположительно нужно использовать команду:\nblender yourblendfilenameorpath --python drawcar.py При запуске на Харизме вставить части кода, помеченные “для генерации на харизме”, и удалить строки, помеченные “для генерации локально”"},"title":"Blender"},"/docs/draw/":{"data":{"":"","draw_cornersimage-corners-color255#draw_corners(image, corners, color=255)":"Наносит на изображение точки в местах, где есть углы списка corners\nПараметры:\nimage: ndarray (width, height, channels) corners: list (n_corners,2) color: int Возвращает: ndarray (width, height, channels)","draw_edgesimage-cnts-color50-50-50#draw_edges(image, cnts, color=(50, 50, 50))":"Рисует на изображении линии по точкам контура cnts, линии в стиле x^1-\u003ex^2,x^2-\u003ex^3 и тд\nПараметры:\nimage: ndarray (width, height, channels) cnts: ndarray (n_cnts,n,2) color: tuple (3,) Возвращает: ndarray (width, height, channels)","draw_treeimage-centresfalse-leafsfalse-nodesfalse-bonesfalse#draw_tree(image, centres=False, leafs=False, nodes=False, bones=False)":"На вход подается бинаризованное изображение. Рисует на инвертированном изображении скелет: точки их центров, листьев, узлов и пикселей скелета\nПараметры:\nimg: ndarray (width, height) centres: Bool leafs: Bool nodes: Bool bones: Bool Возвращает: ndarray (width, height, channels)"},"title":"Draw"},"/docs/fig/":{"data":{"":"","linepoint1-point2#line(point1, point2)":"Возвращает растровые координаты прямой между двумя точками при помощи алгоритма Брезенхема Параметры:\npoint1: tuple (int, int) point2: tuple (int, int) Возвращает: ndarray (n_points,(x,y))","rectpoint1-point2#rect(point1, point2)":"Возвращает растровые координаты прямоугольника ширины 2r, построеного между двумя точками. Не ясно зачем умножать в размерность на 2.\nПараметры:\npoint1: tuple (int, int) point2: tuple (int, int) r: int Возвращает: tuple (n_points, rect_diag*2,2)"},"title":"Fig"},"/docs/generate/":{"data":{"":"","angles_approx_savefolder-images-names-types-step-savetrue#angles_approx_save(folder, images, names, types, step, save=True)":"Вычисление и сохранение распределения углов для всех фотографий одного образца\nПараметры:\nfolder: str path to dir images: ndarray uint8 [[image1_class1,image2_class1,..],[image1_class2,image2_class2,..]..] names: list str [class_name1,class_name2,..] types: list str [class_type1,class_type2,..] step: scalar int [0,N] save: bool","angles_legendimages_amount-name-itype-step-mus-sigmas-amps-norm#angles_legend(images_amount, name, itype, step, mus, sigmas, amps, norm)":"Cоздание легенды распределения углов\nПараметры:\nimages_amount: int name: str itype: str step: int mus: float sigmas: float amps: float norm: int Возвращает: str","beams_legendname-itype-norm-k-angle-b-score-dist_step-dist_mean#beams_legend(name, itype, norm, k, angle, b, score, dist_step, dist_mean)":"Создание легенды для распределения длин полуосей\nПараметры:\nname: str itype: str norm: int k: float angle: float b: float score: float dist_step: int dist_mean: float Возвращает: str","diametr_approx_savefolder-images-names-types-step-pixel-start2-end-3-savetrue-debugfalse#diametr_approx_save(folder, images, names, types, step, pixel, start=2, end=-3, save=True, debug=False)":"Вычисление и сохранение распределения длин а- и б- полуосей и угла поворота эллипса для разных образцов\nПараметры:\nfolder: str images: ndarray uint8 [[image1_class1,image2_class1,..],[image1_class2,image2_class2,..]..] names: list str [class_name1,class_name2,..] types: list str [class_type1,class_type2,..] step: scalar int [0,N] pixel: float start: int end: int save: bool debug: bool Возвращает: None"},"title":"Generate"},"/docs/images_source/":{"data":{"":"Полученые шлифы проходили предварительное микроскопическое исследование с помощью оптической микроскопии до и после травления в реактиве Мураками для выявления включений свободного углерода и фазы, а также растровой электронной микроскопии (РЭМ) и рентгеновского микроанализа на приборе Tescan Vega TS5130 MM, оборудованном энерго- дисперсионным спектрометром LINK производства фирмы Oxford Instruments. Размер изображения 100 на 100 мкм. Размер цифрового изображения 3072 на 1680 пикселей, каждый пиксель имеет 256 оттенков серого."},"title":"Описание снимков"},"/docs/install/":{"data":{"":"Для работы с программным комплексом склонируйте репозиторий и установите модули из файла requirements. Требуемая версия Python - 3.X.\ngit clone https://github.com/dkagramanyan/wc_cv cd wc_cv pip install requirnments.txt Тестовые изображения находятся в хранилище s3 по адресам\nhttps://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co11.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co15.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co25.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co6_2.jpg https://pobedit.s3.us-east-2.amazonaws.com/default_images/Ultra_Co8.jpg"},"title":"Установка"},"/docs/introduction/":{"data":{"":"Добыча полезных ископаемых и строительство сложных сооружений на протяжении многих столетий являются важными задачами. Их объединяет повышенное требование к применяемым инструментам, в частности сверлильным установкам. Зачастую для добычи природного газа, нефти или строительства линий метрополитена требуется сделать глубокие шахты в твердой неоднородной породе, где на бурильную головку оказывается сильное давление и температура. Для такой работы характеристики наконечников бурильной головки должны максимально точно соответствовать требованиям окружающей среды. Например, твердосплавные напайки должны быть достаточно твердыми, чтобы эффективно разрушать породу, но и одновременно пластичными, чтобы не расколоться о случайный камень высокой прочности.\nС развитием материаловедения получилось выделить группу твердых сплавов карбида вольфрама с кобальтом (WC-Co), которые обладают высокими и гибкими прочностными характеристиками. Например, сплав будет более пластичным и меньше подтвержен выкрашиванию зерен, если добавить больше связующего вещества (кобальта). За многие годы успели достаточно подробно изучить все характеристики этого сплава, однако мы не можем утверждать, что у нее изучены все свойства.\nСуществует гипотеза о том, что между физическими характеристиками сплава присутствуют нелинейные зависимости. Есть множество работ по изучению сплавов WC-Co с различным процентным содержанием компонентов, однако тема поиска скрытых взаимосвязей остается нераскрытой. Цель этой работы - разработать программный комплекс для выделения на снимках микроструктур WC-Co важных признаков и поиска зависимостей между характеристиками сплава.\nСамым многообещающими способами поиска зависимостей являются алгоритмы машинного обучения и компьютерного зрения. Современные модели нейронных сетей способны выявлять сложные зависимости между самыми разными видами данных. В арсенале компьютерного зрения присутствует множество алгоритмов, которые эффективно выделяет геометрию на изображениях.\nДля достижения цели необходимо исследовать и протестировать большой набор алгоритмов выделения признаков на снимках микроструктуры сплава. Затем полученные признаки нужно сопоставить характеристиками сплава, такими как: твердость, ударная вязкость, пластичность, коэффициенты ударной адиабаты и тд. Важно также провести моделирование сплава в различных CAD системах для того, чтобы сравнить вычисленные параметры с экспериментальными.\nОжидаемый результат работы - программный комплекс для обработки SEM снимков микроструктур сплава WC-Co и анализ скрытых зависимостей между физическими характеристиками.\nУ данной работы есть явная практическая польза. В случае, если скрытые зависимости действительно есть, то математическая модель сплава WC-Co будет дополнена новыми данными. Как следствие - инженеры при изготовлении и применении твердосплавных напаек будут знать больше о поведении этого сплава при выпекании и работе при различных внешних условиях. Это поможет сократить издержки и повысит ресурс сверлильных установок.\nВажно понимать, что ценность работы не уменьшится, если искомых скрытых зависимостей не окажется. В дальнейшем можно будет использовать разработанный программный комплекс для анализа изображений, других сплавов или других предметных областей, таких как биология и астрономия."},"title":"Введение"},"/docs/logs/":{"data":{"":"","printprogressbariteration-total-prefix-suffix-decimals1-length100-fill-printendr-etanone#printProgressBar(iteration, total, prefix=\u0026rsquo;\u0026rsquo;, suffix=\u0026rsquo;\u0026rsquo;, decimals=1, length=100, fill=\u0026rsquo;█\u0026rsquo;, printEnd=\u0026quot;\\r\u0026quot;, eta=None)":"Вызывает цикл для вывода прогресс бара\nПараметры:\ncurrent iteration: Int total iterations: Int prefix string: Str suffix string: Str positive number of decimals in percent complete: Int character length of bar: Int bar fill character: Str end character (e.g. \"\\r\", \"\\r\\n\"): Str"},"title":"Logs"},"/docs/mark/":{"data":{"":"","get_anglesimage-thr5#get_angles(image, thr=5)":"Возвращает углы с направлением обхода контура против часовой стрелки, углы \u003e180 градусов учитываются. На вход принимает только обработанное изображение\nПараметры:\nimage: ndarray (width, height,1), only preprocessed image thr: int, distance from original image edge to inner image edge (rect in rect) Возвращает: angles ndarray (n), angles coords list (n_angles, 2)","get_contourscls-image-tol3#get_contours(cls, image, tol=3)":"Уменьшение количества точек контура при помощи алгоритма Дугласа-Пекера\nПараметры:\nimage: ndarray (width, height,3) tol: int Maximum distance from original points of polygon to approximated polygonal chain Возвращает: list (N_contours, (M_points,2))","get_mvee_paramsimage-tol02-debugfalse#get_mvee_params(image, tol=0.2, debug=False)":"Возвращает полуоси и угол поворота фигуры minimal volume enclosing ellipsoid, которая ограничивает исходные точки контура эллипсом. Для расчетов центр координатной оси сдвигается на центроид полигона (исследуемого региона), а затем сдвигается на среднее значение координат полигона\nПараметры:\nimage: ndarray (width, height,1), only preprocessed image tol: foat, koef of ellipse compactness Возвращает: ndarray a_beams, b_beams, angles, centroids","get_row_contoursimage#get_row_contours(image)":"Возвращает кооридинаты пикселей контуров каждого региона\nПараметры:\nimage: ndarray (width, height,3) Возвращает: list (N_contours, (M_points,2))","gskeletons_coordsimage#gskeletons_coords(image)":"На вход подается бинаризованное изображение создает массив индивидуальных скелетов пикселю скелета дается класс, на координатах которого он находится. Координаты класса определяются ndi.label\nПараметры:\nimage: ndarray (width, height,1) Возвращает: bones","mark_corners_and_classesimage-max_num100000-sens01-max_dist1#mark_corners_and_classes(image, max_num=100000, sens=0.1, max_dist=1)":"(Deprecated) Возвращает всевозможные координаты углов и исходное изображение с нанесенными классами кластеров градиента\nПараметры:\nimage: ndarray (width, height, channels) max_num: int sens: float max_dist: int Возвращает: corners, classes, num","mean_pixelimage-point1-point2-r#mean_pixel(image, point1, point2, r)":"(Deprecated) Возвращает среднее значение пикселей прямоугольника ширины 2r, построеного между двумя точками\nПараметры:\nimage: ndarray (width, height, channels) point1: tuple (int, int) point2: tuple (int, int) r: int Возвращает: mean, dist","вписывание-регионов-co-в-эллипс#Вписывание регионов Co в эллипс":"Задача вписывания фигуры в эллипс называется minimal volume enclosing ellipsoid. Алгоритм решения задачи был разработан Л.Н.Хачуяном . Мы взяли релизацию этого алгоритма из библиотеки Radio_Beam . Параметры эллипсоида подбираются так, чтобы заданные точки находились внутри фигуры, а ее геометрические характеристики были наименьшими.","класс-grainmark#Класс grainMark":"","определение-углов-у-регионов-co#Определение углов у регионов Co":"Для определения углов последовательно используется 3 инстурмента:\nпоиск границ Кенни. Он находит на изображении все возможные границы и затем выделяет их\nметод поиска конутров Suzuki. Он нужен для разметки (нумерования) пикселей найденных в п.1 контуров. Направление обхода контура - против часовой стрелки. Проверим направление. Точка - начало отрисовки контура\nполученные масивы пикселей контуров аппроксимируются методом Дугласа-Пекера. Он из массива точек оставляет только те точки, которые описывают характер полигона, например: точки в углах, перегибах и тд В итоге для каждого контура мы имеем массив точек, которые с заданной точностью описывают периметр контура.\nДля определения границы воспользуемся определителем тройкой векторов. Если определитель det меньше 0, то угол phi меньше 180 градусов, иначе больше 180.\ngrainMark.get_row_contours(image)"},"title":"Mark"},"/docs/morphology/":{"data":{"":"","kmeans_imageimage-n_clusters#kmeans_image(image, n_clusters)":"Кластеризует при помощи kmeans и возвращает изображение с нанесенными цветами кластеров\nПараметры:\nimage: ndarray (width, height, channels) n_clusters: int Возвращает: (image, colors), colors - list of median colors of the clusters"},"title":"Morphology"},"/docs/nn/":{"data":{"":"Для использования снимков нужно создать модель автоэнкодер, которая из снимков будет вытягивать вектор признаков. Затем этот вектор вместе с вычисленными характеристиками будет отправлться на вход другой нейронной сети, которая будет искать зависимости между входными значениями и физическими характеристиками сплавов","архитектура#Архитектура:":"Веса AE (tf) Веса VQ-VAE-2 (pt)"},"title":"Машинное обучение"},"/docs/preprocess/":{"data":{"":"Описанные инструменты разработаны для обработки SEM снимков.\nДля явного выделения границ фаз WC/Co используется последовательное применение следующиих алгоритом\nвыбирается сторона снимка. По умолчанию использвуется снимок в отраженных электронах\nизображение сглаживается медианным фильтром для подавления шумов и выравнивания цветового распределения пикселей\nслаженное изображение бинаризуется при помощи метода Отсу\nот бинаризованного изображения берется градиент. Он явно показывает переходы вас WC/Co\nбинаризованное изобржение инвертируется и к нему добавляется карта градиентов, полученная в п.4\nПолная обработка изображения выглядит следующим образом:\npreproc_image=1-Otsu(median_filter(image))+grad(Otsu(median_filter(image))) Значения пикселей по классам:\n0 - зерно WC\n127 - регион Co\n254 - граница региона Co, смежного с зернами WC. Толщина границы - 1 пиксель","combineimage-h-k05#combine(image, h, k=0.5)":"Накладывает левую и правые части изображения. Если k=1, то на выходе будет левая часть изображения, если k=0, то будет правая часть\nПараметры:\nimage: ndarray (height,width,channels) h: int scalar k: float scalar Возвращает: ndarray (height,width/2,channels)","do_otsuimage#do_otsu(image)":"Бинаризация Отсу\nПараметры:\nimg: ndarray (height,width,channels) Возвращает: ndarray (height,width), Boolean","get_example_images#get_example_images()":"Скачивает из контейнера s3 по 1 снимку каждого образца\nВозвращает: ndarray [[img1],[img2]..]","image_preprocess_kmeansimage-h135-k1-n_clusters3-pos1#image_preprocess_kmeans(image, h=135, k=1, n_clusters=3, pos=1)":"Выделение границ при помощи кластеризации и выравнивание шума медианным фильтром. Подходит только для смазанных фотограий, где границы у объектов достатчно широкие. Pos отвечает за выбор кластера, который будет отображен на возвращенном изображении\nПараметры:\nimage: array (height,width,channels) h: int scalar k: float scalar n_clusters: int scalar pos: int scalar, cluster index Возвращает: ndarray (height,width)","image_preprocessimage#image_preprocess(image)":"Комбинация медианного фильтра, биноризации и градиента. У зерен значение пикселя - 0, у регионов связ. в-ва - 127,а у их границы - 254. Обраотанное изображение получается следующим образом: 1-Otsu(median_filter(image))+grad(Otsu(median_filter(image)))\nПараметры:\nimg: ndarray (height,width,channels) Возвращает: ndarray (height,width,1)","imdivideimage-h-side#imdivide(image, h, side)":"Разделяет входное изображение по середине и возвращает левую или правую часть\nПараметры:\nimage: ndarray (height,width,channels) h: int scalar side: float scalar Возвращает: ndarray (height,width/2,channels)","read_preprocess_dataimages_dir-max_images_num_per_class100-preprocessfalse-savefalse-crop_bottomfalse-h135-resizetrue-resize_shapenone-save_nameall_imagesnpy#read_preprocess_data(images_dir, max_images_num_per_class=100, preprocess=False, save=False, crop_bottom=False, h=135, resize=True, resize_shape=None, save_name=\u0026lsquo;all_images.npy\u0026rsquo;)":"Считывание всего датасета, обработка и сохрание в .npy файл\nПараметры:\nimages_dir: str max_images_num_per_class: int preprocess: Bool save: Bool crop_bottom: Bool h: int resize: Bool resize_shape: tuple (width, height, channels) save_name: str Возвращает: ndarray (n_classes, n_images_per_class, width, height, channels)","tiff2jpgfolder_path-start_name0-stop_name-4-new_folder_pathresized#tiff2jpg(folder_path, start_name=0, stop_name=-4, new_folder_path=\u0026lsquo;resized\u0026rsquo;)":"Переводит из tiff 2^16 в jpg 2^8 бит\nПараметры:\nfolder_path: str start_name: int stop_name: int new_folder_path: str Возвращает: None","класс-grainpreprocess#Класс grainPreprocess":"","обработка-всего-датасета-снимков#Обработка всего датасета снимков":"all_images=grainPreprocess.read_preprocess_data(images_folder_path, images_num_per_class=150, preprocess=True, save=True)","обработка-одного-снимка#Обработка одного снимка":"img=io.imread(img_path) img=grainPreprocess.image_preprocess(img,h,k)","расположение-снимков#Расположение снимков":"Расположение исходных снимков и предобработанных снимков должно выглядеть следующим образом\nproject │ └───images_folder │ └───class1_images │ image1 │ image2 │ ... └───class2_images │ image1 │ image2 │ ... └───class3_images │ image1 │ image2 │ ..."},"title":"Предобработка изображений"},"/docs/show/":{"data":{"":"","enclosing_ellipse_showimage-pos0-tolerance02-n15#enclosing_ellipse_show(image, pos=0, tolerance=0.2, N=15)":"Выводит точки многоугольника с позиции pos и описанного вокруг него эллипса\nПараметры:\nimage: ndarray (height,width,channels) pos: int tolerance: foat, koef of ellipse compactness N: int Возвращает: None","img_showimage-n20-cmappltcmnipy_spectral#img_show(image, N=20, cmap=plt.cm.nipy_spectral)":"Выводит изображение image\nПараметры:\nimage: ndarray (height,width,channels) N: int cmap: plt cmap Возвращает: None"},"title":"Show"},"/docs/stats/":{"data":{"":"","ellipsea-b-angle-xc0-yc0-num50#ellipse(a, b, angle, xc=0, yc=0, num=50)":"Возвращает координаты эллипса, построенного по заданным параметрам. По умолчанию центр (0,0). Угол в радианах, уменьшение угла обозначает поворот эллипса по часовой стрелке\nПараметры:\na: float b: float angle: float, rad xc: float, center coord x yc: float, center coord y num: int, number of ellipse points Возвращает: tuple (num, 2)","gaussian_bimodalx-mu1-mu2-sigma1-sigma2-amp11-amp21#gaussian_bimodal(x, mu1, mu2, sigma1, sigma2, amp1=1, amp2=1)":"Возвращает бимодальную нормальную фунцию по заданным параметрам\nПараметры:\nx: list (n,) mu1: float mu2: float sigma1: float sigma2: float amp1: float amp2: float Возвращает: list (n,)","gaussian_termodalx-mu1-mu2-mu3-sigma1-sigma2-sigma3-amp11-amp21-amp31#gaussian_termodal(x, mu1, mu2, mu3, sigma1, sigma2, sigma3, amp1=1, amp2=1, amp3=1)":"Возвращает термодальную нормальную фунцию по заданным параметрам\nПараметры:\nx: list (n,) mu1: float mu2: float mu3: float sigma1: float sigma2: float sigma3: float amp1: float amp2: float amp3: float Возвращает: list (n,)","gaussianx-mu-sigma-amp1#gaussian(x, mu, sigma, amp=1)":"Наносит на изображение точки в местах, где есть углы списка corners\nПараметры:\nx: list (n,) mu: float sigma: float amp: float Возвращает: list (n,)","kernel_pointsimage-point-step1#kernel_points(image, point, step=1)":"Возвращает координаты пикселей квадратной матрицы шириной 2*step, центр которой это point\nПараметры:\nimage: ndarray (width, height) point: tuple (2,) step: int Возвращает: tuple (n_points,2)","stats_preprocessarray-step#stats_preprocess(array, step)":"Приведение углов к кратости, например 0,step,2*step и тд\nПараметры:\narray: list, ndarray (n,) step: int Возвращает: array_copy, array_copy_set, dens_curve"},"title":"Stats"},"/docs/usage_angles/":{"data":{"":"","бимодальная-аппроксимация#Бимодальная аппроксимация":"from wc_cv import grainApprox (x_plot, y_plot), mus, sigmas, amps = grainApprox.bimodal_gauss_approx(x, y)","визуализация#Визуализация":"from wc_cv import grainShow # см. также grainShow.angles_plot_base для комплексных графиков","извлечение-углов#Извлечение углов":"from wc_cv import grainPreprocess, grainMark from skimage import io image = io.imread('path.png') proc = grainPreprocess.image_preprocess(image) angles, contours = grainMark.get_angles(proc, border_eps=5, tol=3) def hello(name): print(f\"Hello, {name}\") hello(\"world\")","предобработка-статистики#Предобработка статистики":"from wc_cv import grainStats x, y = grainStats.stats_preprocess(angles, step=5)"},"title":"Углы и их распределения"},"/docs/usage_dataset/":{"data":{"":"SEMDataset подготавливает кэш предобработанных изображений в /tmp/\u003cимя_датасета\u003e и даёт удобный доступ к пути и изображению.","индексация#Индексация":"# получить изображение и путь image, path = dataset.__getitem__(class_idx=0, idx=0)","параметры#Параметры":"images_folder_path: корневая папка с подпапками-классами max_images_num_per_class: лимит изображений на класс (int) no_cache: если True, кэширование пропускается workers: число процессов; по умолчанию cpu_count()-1","примечание#Примечание":"Путь не должен оканчиваться на /. Кэш строится однократно и переиспользуется.","создание-датасета#Создание датасета":"from wc_cv import SEMDataset # создаст кэш, распараллелит загрузку и предпросчёт # исключите завершающий '/' у пути dataset = SEMDataset('data/wc_co', max_images_num_per_class=100)"},"title":"Датасет: SEMDataset"},"/docs/usage_graph/":{"data":{"":"","минимальный-пример#Минимальный пример":"from wc_cv import grainPreprocess, Crack, Viz from skimage import io image = io.imread('path/to/img.png') proc = grainPreprocess.image_preprocess(image) entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = ( Crack.preprocess_graph_image(proc, tol=5) ) G, img_contours_mono = Crack.create_crack_graph( img_contours.shape, cnts, nodes_meta ) Viz.graph_plot(G, img_contours_mono, N=10, M=10)","пайплайн#Пайплайн":"Предобработка входного изображения (grainPreprocess.image_preprocess). Crack.preprocess_graph_image — выделение контуров, подготовка метаданных узлов. Crack.create_crack_graph — построение ориентированного графа по контурам. (Опционально) Energy.get_energies — расчёт энергий путей. Viz.graph_plot — визуализация.","параметры-и-классы#Параметры и классы":"Crack.get_edge_type — типы рёбер: 0 Co, 1 WC-Co, 2 WC, 3 WC-WC. Crack.get_edge_type_labeled — определение типа на размеченных данных. Viz.plot_optimized_energies — матрицы энергий по конфигурациям. Energy.find_shortest_energy_paths — кратчайшие пути по весам."},"title":"Граф трещин: Crack"},"/docs/usage_quickstart/":{"data":{"":"Ниже приведены минимальные примеры использования основных функций пакета wc_cv.","граф-трещин-создание-визуализация#Граф трещин (создание, визуализация)":"from wc_cv import Crack, grainDraw from PIL import Image import numpy as np # подготовка данных (пример) entry_nodes, exit_nodes, img_contours, img_marked, cnts, nodes_meta = Crack.preprocess_graph_image(processed) # граф G, img = Crack.create_crack_graph(img_contours.shape, cnts, nodes_meta) # картинка с контурами img_rgb = grainDraw.draw_contours(Image.fromarray(np.zeros_like(img_contours)), cnts=cnts) Подробнее см. страницы “Датасет”, “Граф трещин” и “Углы”.","извлечение-контуров-и-углов#Извлечение контуров и углов":"from wc_cv import grainMark angles, contours = grainMark.get_angles(processed)","предобработка-одного-снимка#Предобработка одного снимка":"from skimage import io from wc_cv import grainPreprocess image = io.imread('path/to/image.png') processed = grainPreprocess.image_preprocess(image)","работа-с-датасетом-кэширование-в-tmp#Работа с датасетом (кэширование в /tmp)":"from wc_cv import SEMDataset # подготовит кэш и вернёт индексы путей dataset = SEMDataset('dataset_root', max_images_num_per_class=50) image, path = dataset.__getitem__(0, 0)"},"title":"Быстрый старт"}}